[ { "title": "第一篇博客", "url": "/posts/write-a-new-post/", "categories": "Blogging, Tutorial", "tags": "js", "date": "2020-10-15 15:20:00 +0800", "snippet": "Naming and PathCreate a new file named YYYY-MM-DD-TITLE.EXTENSION and put it in the _post/ of the root directory. Please note that the EXTENSION must be one of md and markdown. From v2.4.1, you can create sub-directories under _posts/ to categorize posts.Front MatterBasically, you need to fill th..." }, { "title": "vue", "url": "/posts/vue/", "categories": "", "tags": "vue", "date": "2020-09-16 11:00:00 +0800", "snippet": "vue是一个什么样的框架 它借鉴了MVVM框架，但是和他并不完全一样。相同之处都是数据变化视图会更新，视图变化数据会被影响（响应式数据原理）。不同之处是MVVM不能跳过数据去直接更新视图，而vue可以通过操作dom来更新视图 MVVM模型的组成部分 model（模型）：模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。 view（视图）：视图是用户在屏幕上看到的结构、布局和外观（UI） viewModel（视图模型）： binder（绑定器） 也就是给我什么样的数据，我就渲染出什么样的页面。如下面的html为例..." }, { "title": "js", "url": "/posts/js/", "categories": "", "tags": "js", "date": "2020-09-05 11:20:00 +0800", "snippet": "1.js的基本数据类型，简单类型和复杂类型在内存中的存储方式 简单类型：Number Boolean String null undefined Symbol存储在栈内; 复杂类型：Object存储在堆内 2.jsonp手写原理 3. " }, { "title": "event-loop", "url": "/posts/event-loop/", "categories": "", "tags": "js", "date": "2020-09-02 14:20:00 +0800", "snippet": "浏览器事件循环机制 主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。1.JavaScript是单线程，非阻塞的 JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事. 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。2.任务队列 所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）. 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行..." }, { "title": "webpack", "url": "/posts/webpack/", "categories": "", "tags": "webpack", "date": "2020-08-27 11:20:00 +0800", "snippet": "webpack是什么 定义: webpack 是一个打包模块化 JavaScript 的工具，专注构建模块化项目，在 webpack 里一切文件皆模块，通过 loader 转换文件，通过 plugin 注入钩子，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle loader: 用于对模块的源代码进行转换,描述了 webpack 如何处理 非 JavaScript(non-JavaScript) 模块，并且在 bundle 中引入这些依赖。（这个模块需要导出一个函数。这个导出函数的工作就是..." }, { "title": "http", "url": "/posts/http/", "categories": "", "tags": "js", "date": "2020-08-22 15:20:00 +0800", "snippet": "" }, { "title": "generator", "url": "/posts/generator/", "categories": "", "tags": "js", "date": "2020-08-02 14:20:00 +0800", "snippet": "iterator遍历器 es6上是这样定义的：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作模拟一个遍历器生存函数function makeIterator(arr){ let index = 0 return { next: function(){ if(index &amp;lt; arr.length){ return { value: arr[index++], ..." }, { "title": "数据结构", "url": "/posts/data-structure/", "categories": "", "tags": "js", "date": "2020-07-20 15:20:00 +0800", "snippet": "栈 特点：先进后出class Stack{ constructor(){ this.stack = [] } add(ele){ this.stack.push(ele) } pop(){ this.stack.pop() }}let stack = new Stack()stack.add(1)stack.add(2)stack.pop()console.log(stack)队列 特点：先进先出class Queue{ constructor(){ this.queue = [] ..." }, { "title": "promise对象的几个方法分析", "url": "/posts/promise-all/", "categories": "", "tags": "js", "date": "2020-07-12 10:55:00 +0800", "snippet": "promise.allconst p = Promise.all([p1, p2, p3]);上面代码p的状态由p1、p2、p3决定，分成两种情况。（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。const p2 = new Promise((resolve, reject) =&amp;gt; { resolve(&quot;..." }, { "title": "promise原理", "url": "/posts/promise/", "categories": "", "tags": "js", "date": "2020-07-08 15:20:00 +0800", "snippet": "promise介绍 1.promise是什么? promise对象是一个构造函数。 2.promise的应用场景 Promise 是异步编程的一种解决方案。主要是为了解决回调地狱的问题。下面来看个回调嵌套的小例子：fs.readFile(&quot;name.txt&quot;, &quot;utf8&quot;, function(err,data){ if(data){ fs.readFile(data, &quot;utf8&quot;, function(err1,data1){ // console.log(err1,data1) ..." }, { "title": "leetcode解题", "url": "/posts/leetcode/", "categories": "", "tags": "js", "date": "2020-06-25 15:20:00 +0800", "snippet": "283. 移动零给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。示例：输入: [0,1,0,3,12]输出: [1,3,12,0,0] 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) { var j = 0; for(var i = 0..." }, { "title": "callback", "url": "/posts/callback/", "categories": "", "tags": "js", "date": "2020-06-10 09:20:00 +0800", "snippet": "callback 定义：一个函数作为另一个函数的参数应用场景1.传参//1）方法1，利用call解决//a.js文件function fun2(){ console.log(this) this.fun1(&quot;jyy&quot;)}module.exports = fun2//b.js文件let fun2 = require(&quot;./8.callback.js&quot;)let obj = { name: &quot;123&quot;, fun1: function(name){ obj.name = name }}//此处用call来更改t..." } ]
