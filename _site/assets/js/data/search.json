[ { "title": "xss和csrf", "url": "/posts/xss-csrf/", "categories": "", "tags": "js", "date": "2021-03-12 11:10:00 +0800", "snippet": "xss 跨站脚本攻击：往Web页面里插入恶意Script代码，当用户浏览该页之时，嵌入其中Web里面的Script代码会被执行，从而达到恶意攻击用户的目的。img标签里面也能植入恶意代码。比如http://192.168.1.102/xss/example4.php?name= 反射型xss：相对于访问者而言是一次性的，具体表现在我们把我们的恶意脚本通过url的方式传递给了服务器，而服务器则只是不加处理的把脚本“反射”回访问者的浏览器而使访问者的浏览器执行相应的脚本 存储型xss：储存到数据库中，然后当我们再次访问相同页面时，将恶意脚本从数据库中取出并返回给浏览器执行。xss防范手..." }, { "title": "monitor", "url": "/posts/monitor/", "categories": "", "tags": "js", "date": "2021-03-09 11:10:00 +0800", "snippet": "监控分类 性能监控 数据监控 异常监控衡量性能的指标（时间监控） Resource timing Performance API资源监控 performance.getEntriesByType(“resource”)ajax请求监控 重写 send和open方法进行拦截前端代码异常 window.onerror" }, { "title": "数组api", "url": "/posts/arrayapi/", "categories": "", "tags": "js", "date": "2021-03-03 14:30:00 +0800", "snippet": "forEachlet arr = [1,2,3]Array.prototype.myForEach = function(cb){ for(let i=0; i&amp;lt;this.length; i++){ cb(this[i],i) }}arr.myForEach(item =&amp;gt; console.log(item))maplet arr = [1,2,3]Array.prototype.mymap = function(cb){ let arr1 = [] for(let i=0; i &amp;lt; this.length;..." }, { "title": "cookie session", "url": "/posts/cookie/", "categories": "", "tags": "js", "date": "2021-02-26 12:10:00 +0800", "snippet": "cookie 定义：是在客户端上存储的一个简单的文本文件。这个文件与特定的 Web 网站关联在一起, 保存了该客户机访问这个Web 网站时的信息。同域的网站浏览器默认会自动携带cookie，子域和主域也不能共享cookie，可以设置domain属性为基础主域后才能实现cookie共享。比如www.baidu.com和b.baidu.com不能共享cookie，可以设置domain为baidu.com就能实现共享cookie有以下几个属性 value属性：设置的cookie的值 Expires：设置Cookie的生存期。有两种存储类型的Cookie：会话性与持久性。Expires属性..." }, { "title": "cross domain", "url": "/posts/cross-domain/", "categories": "", "tags": "js", "date": "2021-02-25 11:10:00 +0800", "snippet": "跨域：是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。 同源策略：是指协议，域名，端口都要相同，其中有一个不同都会产生跨域如何解决跨域1.jsonp 1.主要就是利用了 script 标签的src没有跨域限制来完成的 2.只能发送get请求 3.不安全，xss攻击原理：前端自定义一个callback函数，向后端发送一个带有callback参数的get请求，服务端返回一个callback的执行函数并且带有参数。前端就会执行这个callback函数并且拿到其中的参数。//原生js实现&amp;lt;script&amp;gt;..." }, { "title": "模块化", "url": "/posts/module/", "categories": "", "tags": "js", "date": "2021-02-11 10:10:00 +0800", "snippet": "1.模块化发展历程 命名空间模式 -》 自执行函数 -》commonjs -》amd -》umd -》cmd -》esm2.为什么需要模块化1.团队多人协作，需要引用别人的代码2.项目交接，我们在阅读和重构别人的代码3.不同的环境，环境变量不同基于以上场景，当前js模块化主要有以下几个目的：1.防止污染全局作用域2.代码复用性和可维护性3.功能代码松耦合4.解决依赖关系不明显的问题3.命名空间模式 这种方式”污染”了全局变量，这样的写法会暴露所有模块内的成员，内部状态可以被外部改写var mathUtils1 = { add: function(x, y) { r..." }, { "title": "深拷贝和浅拷贝", "url": "/posts/deepclone/", "categories": "", "tags": "js", "date": "2021-02-11 10:10:00 +0800", "snippet": "浅拷贝 会创建一个新对象，该对象会完全复制原始对象，如果属性是基础类型，就复制的值，如果属性是引用类型，就复制的地址。Object.assign,Array.prototype.concat(),Array.prototype.slice()也都是浅拷贝。Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组function shallowClone(obj){ var o = {} for(var key in obj){ if(obj.hasOwnProperty(key)){ o[key..." }, { "title": "第一篇博客", "url": "/posts/write-a-new-post/", "categories": "Blogging, Tutorial", "tags": "js", "date": "2020-10-15 15:20:00 +0800", "snippet": "Naming and PathCreate a new file named YYYY-MM-DD-TITLE.EXTENSION and put it in the _post/ of the root directory. Please note that the EXTENSION must be one of md and markdown. From v2.4.1, you can create sub-directories under _posts/ to categorize posts.Front MatterBasically, you need to fill th..." }, { "title": "vue", "url": "/posts/vue/", "categories": "", "tags": "vue", "date": "2020-09-16 11:00:00 +0800", "snippet": "vue是一个什么样的框架 它借鉴了MVVM框架，但是和他并不完全一样。相同之处都是数据变化视图会更新，视图变化数据会被影响（响应式数据原理）。不同之处是MVVM不能跳过数据去直接更新视图，而vue可以通过操作dom来更新视图 MVVM模型的组成部分 model（模型）：模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。 view（视图）：视图是用户在屏幕上看到的结构、布局和外观（UI） viewModel（视图模型）： binder（绑定器） 也就是给我什么样的数据，我就渲染出什么样的页面。如下面的html为例..." }, { "title": "排序", "url": "/posts/sort/", "categories": "", "tags": "js", "date": "2020-09-05 11:20:00 +0800", "snippet": "选择排序插入排序冒泡排序快速排序" }, { "title": "js", "url": "/posts/js/", "categories": "", "tags": "js", "date": "2020-09-05 11:20:00 +0800", "snippet": "1.js的基本数据类型，简单类型和复杂类型在内存中的存储方式 简单类型：Number Boolean String null undefined Symbol存储在栈内; 复杂类型：Object存储在堆内 2.jsonp手写原理 3. " }, { "title": "event-loop", "url": "/posts/event-loop/", "categories": "", "tags": "js", "date": "2020-09-02 14:20:00 +0800", "snippet": "浏览器事件循环机制 主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。1.JavaScript是单线程，非阻塞的 JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事. 单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。2.任务队列 所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）. 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行..." }, { "title": "webpack", "url": "/posts/webpack/", "categories": "", "tags": "webpack", "date": "2020-08-27 11:20:00 +0800", "snippet": "webpack是什么 定义: webpack 是一个打包模块化 JavaScript 的工具，专注构建模块化项目，在 webpack 里一切文件皆模块，通过 loader 转换文件，通过 plugin 注入钩子，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle loader: 用于对模块的源代码进行转换,描述了 webpack 如何处理 非 JavaScript(non-JavaScript) 模块，并且在 bundle 中引入这些依赖。（这个模块需要导出一个函数。这个导出函数的工作就是..." }, { "title": "http", "url": "/posts/http/", "categories": "", "tags": "js", "date": "2020-08-22 15:20:00 +0800", "snippet": "" }, { "title": "generator", "url": "/posts/generator/", "categories": "", "tags": "js", "date": "2020-08-02 14:20:00 +0800", "snippet": "iterator遍历器 es6上是这样定义的：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作模拟一个遍历器生存函数function makeIterator(arr){ let index = 0 return { next: function(){ if(index &amp;lt; arr.length){ return { value: arr[index++], ..." }, { "title": "数据结构", "url": "/posts/data-structure/", "categories": "", "tags": "js", "date": "2020-07-20 15:20:00 +0800", "snippet": "栈 特点：先进后出class Stack{ constructor(){ this.stack = [] } add(ele){ this.stack.push(ele) } pop(){ this.stack.pop() }}let stack = new Stack()stack.add(1)stack.add(2)stack.pop()console.log(stack)队列 特点：先进先出class Queue{ constructor(){ this.queue = [] ..." }, { "title": "promise对象的几个方法分析", "url": "/posts/promise-all/", "categories": "", "tags": "js", "date": "2020-07-12 10:55:00 +0800", "snippet": "promise.allconst p = Promise.all([p1, p2, p3]);上面代码p的状态由p1、p2、p3决定，分成两种情况。（1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。（2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。const p2 = new Promise((resolve, reject) =&amp;gt; { resolve(&quot;..." }, { "title": "promise原理", "url": "/posts/promise/", "categories": "", "tags": "js", "date": "2020-07-08 15:20:00 +0800", "snippet": "promise介绍 1.promise是什么? promise对象是一个构造函数。 2.promise的应用场景 Promise 是异步编程的一种解决方案。主要是为了解决回调地狱的问题。下面来看个回调嵌套的小例子：fs.readFile(&quot;name.txt&quot;, &quot;utf8&quot;, function(err,data){ if(data){ fs.readFile(data, &quot;utf8&quot;, function(err1,data1){ // console.log(err1,data1) ..." }, { "title": "leetcode解题", "url": "/posts/leetcode/", "categories": "", "tags": "js", "date": "2020-06-25 15:20:00 +0800", "snippet": "283. 移动零给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。示例：输入: [0,1,0,3,12]输出: [1,3,12,0,0] 必须在原数组上操作，不能拷贝额外的数组。 尽量减少操作次数。 /** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */var moveZeroes = function(nums) { var j = 0; for(var i = 0..." }, { "title": "callback", "url": "/posts/callback/", "categories": "", "tags": "js", "date": "2020-06-10 09:20:00 +0800", "snippet": "callback 定义：一个函数作为另一个函数的参数应用场景1.传参//1）方法1，利用call解决//a.js文件function fun2(){ console.log(this) this.fun1(&quot;jyy&quot;)}module.exports = fun2//b.js文件let fun2 = require(&quot;./8.callback.js&quot;)let obj = { name: &quot;123&quot;, fun1: function(name){ obj.name = name }}//此处用call来更改t..." } ]
