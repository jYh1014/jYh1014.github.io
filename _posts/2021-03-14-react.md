---
title: react
author: jyy
date: 2021-03-14 11:10:00 +0800
# categories: [Blogging, Tutorial]
tags: [react]
pin: true
---

## jsx

- 什么是jsx？是一种 JavaScript 的语法扩展，用来描述用户界面。看起来更像是javascript + html。
- 为什么要用jsx？不用引入太多的概念和语法，只写js就能将页面呈现出来。React 认为渲染逻辑本质上与其他 UI 逻辑内在耦合，比如，在 UI 中需要绑定处理事件、在某些时刻状态发生变化时需要通知到 UI，以及需要在 UI 中展示准备好的数据
- jsx的工作原理？jsx浏览器无法识别，经过babel转义，其实是React.createElement的语法糖。
- jsx其实也是普通的js对象。


## react元素

> 元素是构成 React 应用的最小单位,JSX 就是用来声明 React 当中的元素.与浏览器的 DOM 元素不同，React 当中的元素事实上是普通的对象(虚拟dom),ReactDOM来确保浏览器中的DOM数据和React元素保持一致.

## 虚拟dom

- 什么是虚拟dom？其实就是一个普通的js对象，来描述对应dom中的真实节点的抽象，再通过render方法将其渲染成真实的dom节点插入到页面里。
- 虚拟dom的优点？避免通过操作dom的方式来达到视图更新的目的，因为这样会造成整个页面都刷新。而虚拟dom这种方式每次只是js对象的更改，然后通过对前后虚拟dom的对比，从而找出变更的部分进行部分更新。

## 函数组件和类组件
- 函数组件是一个纯函数
- 函数组件没有状态，没有生命周期，也没有this.
- 函数组件不需要生成实例

### 纯函数

- 不能修改入参
- 不能修改函数作用域外的的变量，其实也就是在执行过程中不能产生副作用（调用 DOM API 修改页面、发送了 Ajax 请求、window.reload、console.log也是副作用）
- 如果参数相同，那返回结果一定相同。

## 合成事件

- 在组件中的事件处理函数中拿到的事件对象并不是原生的事件对象，而是经过React合成的SyntheticEvent对象。它解决了不同浏览器之间的兼容性差异。抽象成统一的事件对象。
- React组件上声明的事件最终绑定到了document这个DOM节点上，也就是说触发事件的时候会先进行原生冒泡到document上，而不是React组件对应的DOM节点。故只有document这个节点上面才绑定了DOM原生事件，其他节点没有绑定事件。这样简化了DOM原生事件，减少了内存开销
- react在自己的合成事件中重写了 stopPropagation方法，然后在遍历每一级事件的过程中根据isPropagationStopped属性判断是否继续收集父级绑定相同事件的回调函数，如果不需要不收集最后就遍历执行之前收集好的回调函数。
- e.stopPropagation只是阻止了合成事件里面的冒泡，并没有阻止原生事件的冒泡。
- 和批量更新也有关系，在事件回调函数处理前将isBatchingUpdate批量更新属性设置为true表示是异步更新，处理后设置为false。
- 事件同步代码执行完成后，合成事件对象里面的属性都置为null,如果想要在setTimeout等代码里获取到SyntheticEvent对象，就要使用persist持久化。

 ```js
 let updateQueue = {
     updaters: [],
     add(updater){
         this.updaters.push(updater)
     },
     batchUpdate(){
         this.updaters.forEach(updater=>updater.updateComponent())
     }
 }
function addEvent(dom, eventType, listener) {
    let store = dom.store || (dom.store = {})
    store[eventType] = listener
    document.addEventListener(eventType.slice(2), dispatchEvent, false)
}
let syntheticEvent = {}
function dispatchEvent(event) {
    let { target, type } = event
    let eventType = "on" + type
    while (target) {
        let { store } = target
        if(store){
            let listener = store[eventType]
            if (listener) {
                syntheticEvent.nativeEvent = event
                for (let key in event) {
                    syntheticEvent[key] = event[key]
                }
                //还会根据是否阻止冒泡来判断是否向下执行
                updateQueue.isBatchingUpdate = true
                listener.call(target, event)
                // updateQueue.isBatchingUpdate = false
                updateQueue.batchUpdate() //
                for (let key in syntheticEvent) {
                    syntheticEvent[key] = null
                }
            }
        }
        target = target.parentNode
    }
} 
``` 

## setState

- setState本身并不是异步的，只是在生命周期钩子和合成事件里面，会先将参数状态缓存起来，等同步代码执行完后再执行状态更新。在别的原生事件或者promise、定时器等里面都是同步执行的。
- 把调用setState的组件缓存到一个队列（脏组件）里面，当调用batchUpdate方法的时候，遍历所有的脏组件（状态需要更新而目前还没更新）依次执行组件实例的updateComponent方法。

```js
 let updateQueue = {
     updaters: [],
     add(updater){
         this.updaters.push(updater)
     },
     batchUpdate(){
         this.updaters.forEach(updater=>updater.updateComponent())
     }
 }
class Component{
    constructor(props){
        this.props = props
        this.$updater = new Updater(this)
    }
    setState(partialState,callback){
        this.$updater.addState(partialState,callback)
    }
    forceUpdate(){
        if(this.componentWillUpdate){
            this.componentWillUpdate()
        }
        let oldDOM = this.dom
        let newVdom = this.render()
        //此处应该进行domdiff的操作，而不是完全替换掉之前的dom
        let newDOM = createDOM(newVdom)//将虚拟dom转化成真实dom
        oldDOM.parentNode.replaceChild(newDOM, oldDOM)
        this.dom = newDOM
        if(this.componentDidUpdate){
            this.componentDidUpdate()
        }
    }
}
class Updater{
    constructor(instance){
        this.instance = instance
        this.pendingState = []
        this.callbacks=[]
    }
    addState(partialState,callback){
        this.pendingState.push(partialState)
        if(callback) this.callbacks.push(callback)
        this.emitUpdate()
    }
    emitUpdate(){
        if(updateQueue.isBatchingUpdate){
            updateQueue.add(this) //脏组件缓存到updateQueue里面等待批量更新
        }else{
            this.updateComponent()
        }
    }
    updateComponent(){
        let {pendingState,instance,nextProps} = this
        if(pendingState.length > 0 ){
            this.shouldUpdate(instance,nextProps, this.getState())
        }
    }
    getState(){
        let {classInstance, pendingStates} = this
        let {state} = classInstance
        this.state = this.pendingStates.reduce((prev, current) => {
            let nextState = typeof current === "function" ? current(prev) : current
            prev = { ...prev, ...nextState }
            return prev
        }, this.state) //nextState会合并以前相同key的state
        this.callbacks.forEach(cb => cb())
        return this.state
    }
    shouldUpdate(instance,nextProps,nextState){
        instance.state = nextState
        instance.props = nextProps
        if(instance.shouldComponentUpdate && !instance.shouldComponentUpdate(nextProps,nextState)){
            return
        }
        instance.forceUpdate()
    }
}
```

- 注意：在componentWillUpdate componentDidUpdate shouldComponentUpdate这几个生命周期设置state容易造成死循环。
- 


## 生命周期新版

- 废弃了componentWillMount和componentWillUpdate和componentWillReceiveProps
- 新增了getDerivedStateFromProps和getSnapshotBeforeUpdate这两个生命周期

###  废弃的原因
- 启用了fiber之后就是通过异步的方式进行渲染，在 render 函数之前的所有函数都有可能被执行多次。(待fiber理解之后更新)

### getDerivedStateFromProps（nextProps,prevState）

- static getDerivedStateFromProps(props, state)是类组件的静态方法，在组件初始化和组件更新都会执行。是在组件的render方法之前调用，返回一个state对象来更新状态，或者返回null来不更新任何内容。新的 getDerivedStateFromProps 实际上与 componentDidUpdate 一起取代了以前的 UNSAFE_componentWillReceiveProps 函数
- 静态方法不依赖组件实例而存在，故在该方法内部是无法访问 this 的.所以我们无法做一些不合理的操作比如请求数据，setState等等，尽量来保持生命周期行为的可控可预测。
- 其实就是根据props来更新状态

### getSnapshotBeforeUpdate（prevProps, prevState）

- 是在组件的render方法调用之后新的dom还未挂载页面之前执行，这个时候就能获取到老的dom来做一些操作。其返回值将作为参数传递给componentDidUpdate。
- 在最近一次渲染输出

## ref
- 不能给函数组件挂ref属性，因为内部是ref。current = 实例。而函数组件没有实例，可以用forward。ref解决

## dom diff

### diff策略

- DOM节点跨层级的可以忽略不计
- 拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构。

### tree diff

- 新旧虚拟dom进行同层次的比较，如果发现新节点中其中一个子节点消失了，那直接删除老的虚拟dom并不会进行移动。

### component diff

- 如果是同一类型的组件，比如都是元素类型，那就继续向下比较看是否是同一元素类型，比如都是div，如果不是则就将此节点以及子节点都删除重新创建

- 如果不是同一类型组件直接重新创建。

### element diff




- 新旧虚拟dom进行同层次的比较，如果发现新节点消失了，那直接删除老的虚拟dom并不会进行移动。
- 如果不是同一类型组件直接重新创建
- 如果是同一类型的元素，还要区分以下几种情况：
    - 如果都是类组件，则将取出类组件实例的更新器，调用updater里面的emitUpdate方法，将nextProps传递进去，然后判断类组件是否需要更新即调用shouldupdate方法（此时就会计算最新的状态），如果需要更新则调用类组件实例的render方法，得到新的虚拟dom然后再进行diff
    - 如果都是函数组件，则执行这个函数，得到新的虚拟dom，进行diff，也就是调用compareTwoElements方法。

    - 新旧节点为同一普通dom元素类型进行以下步骤更新
        - 更新自身属性，然后递归对子节点进行更新，下面就介绍如何更新子节点
        - 对老的dom节点生成一个map对象，结构{[key]: 元素节点}
        - 遍历新节点数组，看是否能在map对象里找到相同的key，若找到就复用老节点，需要进行移动操作。
        - 在移动前需要进行一些比较，将当前节点在老的节点集合里面的下标_mountIndex和lastIndex（表示在老集合中不需要移动的最大位置。）进行比较，若 _mountIndex<lastIndex，就将此元素做个标记为需要移动然后放到一个queue里面。
        具体移动到下标值为当前节点在新节点集合中的下标的位置。否则将不移动，移动操作结束后，要将lastIndex置为Math.max(oldChild._mountIndex, lastIndex)，然后将lastIndex置为当前节点在新节点集合中的下标的位置。
        - 更新此节点属性，然后递归比较子节点。若没找到相同的key，就将此元素做个标记为需要插入然后放到一个queue里面。
        - 然后遍历老的节点数组，看新节点数组是否有，若没有就将老节点数组中的这个节点置为null。
        - 遍历完后再对queue数组进行移动和插入操作。