---
title: promise原理
author: jyy
date: 2020-07-08 15:20:00 +0800
tags: [js]
pin: true
---

## promise介绍
> **1.promise是什么?**   
promise对象是一个构造函数。

> **2.promise的应用场景**   
Promise 是异步编程的一种解决方案。主要是为了解决回调地狱的问题。下面来看个回调嵌套的小例子：

```sh
fs.readFile("name.txt", "utf8", function(err,data){
    if(data){
        fs.readFile(data, "utf8", function(err1,data1){
            // console.log(err1,data1)
        })
    }
})
改造成promise后，用链式调用的方式。
function readFile(...args) {
    return new Promise((resolve, reject) => {
        fs.readFile(...args, (err, data) => {
            if(err) reject(err)
            resolve(data)
        })
    })
}
readFile("name.txt", "utf8").then(data => {
    return readFile(data, "utf8");
}, err => {
    console.log("err1"+err)
})
```

> **3.promise原理**    

首先实现一个最简单的： 
```js
let promise = new Promise((resolve, reject) => {
    resolve("ok")
    console.log(111)
})
promise.then(data => {
    console.log("success: " + data)
}, err => {
    console.log("error: " + err)
})
源码实现如下：
class Promise {
    constructor(executor){
        this.value = undefined
        this.reason = undefined
        let resolve = (value) => {
            this.value = value
        }
        let reject = (reason) => {
            this.reason = reason
        }
        executor(resolve, reject)
    }
    then(onfulfilled, onreject){
        onfulfilled(this.value)
    }
}
module.exports = Promise
```
resolve是异步操作成功后执行的，如果异步操作失败则要执行reject,此时就要考虑加状态，成功"FULFILLED"、失败"REJECTED"、进行中"PENDDING"
```js
let promise = new Promise((resolve, reject) => {
    reject("出错了")
})
//源码实现：
const PENDDING = "PENDDING"
const FULFILLED = "FULFILLED"
const REJECTED = "REJECTED"
class Promise{
    constructor(executor){
        this.value = undefined
        this.reason = undefined
        this.status = undefined
        let resolve = (value) => {//
            this.value = value
            this.status = FULFILLED 
        }
        let reject = (reason) => {
            this.reason = reason
            this.status = REJECTED
        }
        executor(resolve, reject)
    }
    then(onfulfilled, onreject){
        if(this.status === FULFILLED){
            onfulfilled(this.value)
        }
        if(this.status === REJECTED){
            onreject(this.reason)
        }
        
    }
}
module.exports = Promise
```
到此一个简单的promise源码已经差不多了，但是实际应用中往往很复杂，最常见的就是和定时器的组合。

```js
let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("ok")
    },1000)
})
promise.then(data => {
    console.log("success: " + data)
}, err => {
    console.log("error: " + err)
})
这种情况需要利用resolveCallbacks和rejectCallbacks来做一个缓存数组。

class Promise{
    constructor(executor){
        this.value = undefined
        this.reason = undefined
        this.status = PENDDING
        this.resolveCallbacks = []
        this.rejectCallbacks = []
        let resolve = (value) => {
            this.value = value
            this.status = FULFILLED 
            this.resolveCallbacks.forEach(fn => fn())
        }
        let reject = (reason) => {
            this.reason = reason
            this.status = REJECTED
            this.rejectCallbacks.forEach(fn => fn())
        }
        executor(resolve, reject)
    }
    then(onfulfilled, onreject){
        if(this.status === FULFILLED){
            onfulfilled(this.value)
        }
        if(this.status === REJECTED){
            onreject(this.reason)
        }
        if(this.status === PENDDING){
            this.resolveCallbacks.push(() => {
                onfulfilled(this.value)
            })
            this.rejectCallbacks.push(() => {
                onreject(this.reason)
            })
        }
    }
}
module.exports = Promise
```
es6文档上写的promise其中一个特点是一旦状态改变，就不会再变，但是看下面代码：
```sh
let promise = new Promise((resolve, reject) => {
    resolve("ok")
    reject("出错了")
})
promise.then(data => {
    console.log("success: " + data)
}, err => {
    console.log("error: " + err)
})
promise的最终状态竟然是reject，正确的状态应该是resolve。
修改一下源码：

class Promise {
    constructor(executor) {
        this.value = undefined
        this.reason = undefined
        this.status = PENDDING
        this.resolveCallbacks = []
        this.rejectCallbacks = []
        let resolve = (value) => {
            if (this.status === PENDDING) {
                this.value = value
                this.status = FULFILLED
                this.resolveCallbacks.forEach(fn => fn())
            }
        }
        let reject = (reason) => {
            if (this.status === PENDDING) {
                this.reason = reason
                this.status = REJECTED
                this.rejectCallbacks.forEach(fn => fn())
            }
        }
        executor(resolve, reject)
    }
    then(onfulfilled, onreject) {
        ...
    }
}
module.exports = Promise

注意：then方法是可以链式调用的，所以then方法的返回值应该是一个新的promise实例。
 then(onfulfilled, onreject) {
    let p = new Promise((resolve, reject) => {
        if (this.status === FULFILLED) {
            onfulfilled(this.value)
        }
        if (this.status === REJECTED) {
            onreject(this.reason)
        }
        if (this.status === PENDDING) {
            this.resolveCallbacks.push(() => {
                onfulfilled(this.value)
            })
            this.rejectCallbacks.push(() => {
                onreject(this.reason)
            })
        }
    })
    return p
}

再看下面这种情况，then方法里面返回的是一个promise，此时要对then方法对返回值做一下判断，然后进行不同的处理：
let promise = new Promise((resolve, reject) => {
    resolve("ok1")
})
let p1 = promise.then(data => {
    console.log("success1:" + data)
    return new Promise((resolve, reject) => {
        resolve("ok2")
    })
}, err => {
    console.log("error1: "+err)
})
let p2 = p1.then(data => {
    console.log("success2:" + data)
}, err => {
    console.log("error2: "+err)
})
解决如下：
    then(onfulfilled, onreject) {
        let p = new Promise((resolve, reject) => {
            if (this.status === FULFILLED) {
                setTimeout(() => {
                    try{
                        let x = onfulfilled(this.value)
                        resolvePromise(p, x, resolve, reject)
                    }catch(e){
                        reject(e)
                    }
                })
            }
            if (this.status === REJECTED) {
                setTimeout(() => {
                    try{
                        let x = onreject(this.reason)
                        resolvePromise(p, x, resolve, reject)
                    }catch(e){
                        reject(e)
                    }
                })
                
            }
            if (this.status === PENDDING) {
                this.resolveCallbacks.push(() => {
                    setTimeout(() => {
                        try{
                            let x = onfulfilled(this.value)
                            resolvePromise(p, x, resolve, reject)
                        }catch(e){
                            reject(e)
                        }
                    })
                })
                this.rejectCallbacks.push(() => {
                    setTimeout(() => {
                        try{
                            let x = onreject(this.reason)
                            resolvePromise(p, x, resolve, reject)
                        }catch(e){
                            reject(e)
                        }
                    })
                })
            }
        })
        return p
    }

const resolvePromise = (p, x, resolve, reject) => {
    //判断x的类型
    if(typeof x === "object" && x !== null || typeof x === "function"){
        try{
            let then = x.then
            if(typeof then === "function"){
                //x是promise就采用promise执行的结果
                x.then(y => resolve(y),r => reject(r))
            }
        }catch(e){
            reject(e)
        }
    }else{
        resolve(x)
    }
}
此时，如果then方法里面返回的promise是下面这样的该怎么解决：
let promise = new Promise((resolve, reject) => {
    resolve("ok1")
})
let p1 = promise.then(data => {
    console.log("success1:" + data)
    return new Promise((resolve, reject) => {
        resolve(new Promise(() => {
            resolve("ok2")
        }))
    })
}, err => {
    console.log("error1: "+err)
})
let p2 = p1.then(data => {
    console.log("success2:" + data)
}, err => {
    console.log("error2: "+err)
})
采用递归的方式一直执行resolvePromise方法
const resolvePromise = (p, x, resolve, reject) => {
    //判断x的类型
    if(typeof x === "object" && x !== null || typeof x === "function"){
        try{
            let then = x.then
            if(typeof then === "function"){
                //x是promise就采用promise执行的结果
                x.then(y => resolvePromise(p, y, resolve, reject),r => reject(r))
            }
        }catch(e){
            reject(e)
        }
    }else{
        resolve(x)
    }
}
```

## 如何中断一个promise链
> 就是返回一个等待的promsie

```sh
let p = new Promise((resolve, reject) => {
    resolve()
})
p.then(() => {
    console.log("1111")
    return new Promise(() => { })
}).then(() => {
    console.log("2222")
})
```