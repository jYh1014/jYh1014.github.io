---
title: 作用域和作用域链
author: jyy
date: 2020-12-17 16:20:00 +0800
tags: [js]
pin: true
---

## 作用域

- 代码中定义变量的区域就叫作作用域。
- 规定了如何查找变量的规则，也就是规定变量访问范围的规则。
- js采用的是词法作用域（静态作用域），就是函数的作用域是在函数定义的时候就确定了。而动态作用域是函数调用的时候才确定的。

## 执行上下文

- 当js执行一段可执行代码的时候，就会创建一个执行上下文。
- 分为全局执行上下文（window对象，只有一个）和函数执行上下文。
- 每个执行上下文都包括三个属性：
    - 变量对象（VO）
    - 作用域链（scope chain）
    - this
- 分为两个阶段执行：编译阶段和执行阶段

## 执行上下文栈
- 在js执行过程中会产生多个执行上下文，会用执行上下文栈来管理。具有先进后出的特性。
- 栈底永远是全局上下文，栈顶为当前正在执行的上下文
- 当执行一个函数的时候会创建一个执行上下文压入栈，执行完毕后弹出栈。

### 变量对象

- 存储了上下文中定义的变量和函数声明
- 分为全局上下文中的变量对象（window）和函数上下文中的变量对象。
    - 编译阶段
        - 首先获取所有用function声明的函数，函数名为变量对象的属性名，值为函数对象，如果属性已经存在，则会用新值覆盖。
        - 其次再依次处理var声明的变量，由名称和对应值（undefined）组成一个变量对象的属性被创建。如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性
    - 执行阶段
        - 给变量对象的属性赋值。

```js
var foo = 1
console.log(foo)
function foo(){
    console.log("foo")
}
//输出是1
//分析过程
1.创建全局执行上下文
let globalContext = {
    globalContextVO: {
        foo: ()=>{}, //先处理函数声明
        foo: undefined
    },
    this: window,
    scope: [globalContextVO]
}
2.执行阶段
let globalContext = {
    globalContextVO: {
        foo: ()=>{}, //先处理函数声明
        foo: 1
    },
    this: window,
    scope: [globalContextVO]
}
```
### 激活对象

- 只有当进入一个执行上下文中，当前的变量对象才会被激活。也就是当前上下文处于栈的顶部。只有激活对象的各种属性才能被访问。
- 只是和变量对象处于上下文不同的生命周期而已。

## 作用域链
- 是在函数创建的时候就确定了
- 当查找变量的时候，先从当前上下文的变量对象中查找，如果找不到，就会从父级变量对象中查找，一直找到全局上下文的变量对象也就是全局对象为止。这样由多个执行上下文的变量对象构成的链表就叫作作用域链。

```js
function one(){
    var a = 1
    function two(){
        var b =2
    }
    return two
}
var a = 2
var two = one();
two();
//过程分析
1.创建全局上下文

let globalContext = {
    VO: {
        one: ()=>{},
        a: undefined,
        two: undefined
    },
    this: window,
    scopechain: [globalContextVO]
}
let ECStack = [globalContext] //执行上下文栈
2.开始执行one函数
    2-1.one函数编译阶段
let oneContext = {
    VO: {
        two: {()=>{},[scope]: [oneContextVO,globalContextVO]},//two函数创建的时候作用域链就已经有了
        a: undedfined
    },
    this: window,
    scopechain: [oneContextVO, globalContextVO]
}
ECStack.push(oneContext)
    2-2.one函数执行阶段
let oneContext = {
    VO: {
        two: {()=>{},[scope]: [globalContextVO]},//two函数创建的时候作用域链就已经有了
        a: 1
    },
    this: window,
    scopechain: [oneContextVO, globalContextVO]
}
ECStack.pop()
3.开始执行two函数
 3-1.two函数编译阶段
  let twoContext = {
      VO: {
          b: undefined
      },
      this: window,
      scopechain: [twoContextVO,oneContextVO, globalContextVO] //当执行two函数的时候，将当前激活对象添加到作用域链的顶端。
  }
  ECStack.push(twoContext)
  3-2.two函数执行阶段
   let twoContext = {
      VO: {
          b: 2
      },
      this: window,
      scopechain: [twoContextVO,oneContextVO, globalContextVO]
  }
  ECStack.pop()
```

## 闭包

- 闭包有两部分构成：一个是当前的执行上下文A，一个是在当前执行上下文中创建的函数B
- 当B执行的时候，引用了A中的变量就产生了闭包。

- 应用场景
    - 柯里化
    - 保护内部私有变量（模块化）