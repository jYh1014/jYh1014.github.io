I",%<ul id="markdown-toc">
  <li><a href="#webpack是什么" id="markdown-toc-webpack是什么">webpack是什么</a></li>
  <li><a href="#webpack的运行流程" id="markdown-toc-webpack的运行流程"><strong>webpack的运行流程</strong></a></li>
  <li><a href="#常用的loader" id="markdown-toc-常用的loader">常用的loader</a></li>
  <li><a href="#常用的plugin" id="markdown-toc-常用的plugin">常用的plugin</a></li>
  <li><a href="#性能优化" id="markdown-toc-性能优化">性能优化</a></li>
  <li><a href="#webpack路由懒加载" id="markdown-toc-webpack路由懒加载">webpack路由懒加载</a></li>
  <li><a href="#webpack和gulp的使用以及区别" id="markdown-toc-webpack和gulp的使用以及区别">webpack和gulp的使用以及区别</a></li>
  <li><a href="#webpack解决跨域的原理http-proxy-middleware代理中间件" id="markdown-toc-webpack解决跨域的原理http-proxy-middleware代理中间件">webpack解决跨域的原理：http-proxy-middleware代理中间件</a></li>
</ul>

<hr />

<p>title: webpack
author: jyy
date: 2020-08-27 11:20:00 +0800
tags: [webpack]
pin: true
—</p>

<h2 id="webpack是什么">webpack是什么</h2>

<blockquote>
  <p>定义: webpack 是一个打包模块化 JavaScript 的工具，专注构建模块化项目，在 webpack 里一切文件皆模块，通过 loader 转换文件，通过 plugin 注入钩子，它会递归地构建一个依赖关系图(dependency graph)，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle</p>
</blockquote>

<blockquote>
  <p>loader: 用于对模块的源代码进行转换,描述了 webpack 如何处理 非 JavaScript(non-JavaScript) <em>模块</em>，并且在 bundle 中引入这些依赖。（这个模块需要导出一个函数。这个导出函数的工作就是获得处理前的原内容，对原内容执行处理后，返回处理后的内容。）</p>
</blockquote>

<blockquote>
  <p>plugin: 是一个具有 apply 属性的 JavaScript 对象,apply 属性会被 webpack compiler 调用，并且 compiler 对象可在整个编译生命周期访问。webpack 运行的生命周期中会广播出许多事件，plugin 可以监听这些事件，在合适的时机通过 webpack 提供的 API 执行相应的操作</p>
</blockquote>

<blockquote>
  <p>loader和plugin的区别：loader操作的是文件；plugin是基于事件机制，监听这些事件，在合适的时机通过 webpack 提供的 API 执行相应的操作。针对整个构建过程起作用，</p>
</blockquote>

<h2 id="webpack的运行流程"><strong>webpack的运行流程</strong></h2>

<ul>
  <li>1.初始化参数: 从配置文件以及 <strong><em>shell</em></strong>语句、webpack默认配置中得到最终的参数</li>
  <li>2.开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；</li>
</ul>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td> --><td class="rouge-code"><pre><span class="kd">const</span> <span class="nx">webpack</span> <span class="o">=</span> <span class="p">(</span><span class="nx">options</span><span class="p">,</span> <span class="nx">callback</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">options</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">object</span><span class="dl">"</span><span class="p">){</span>
        <span class="nx">options</span><span class="p">.</span><span class="nx">context</span> <span class="o">=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">context</span> <span class="o">||</span> <span class="nx">process</span><span class="p">.</span><span class="nx">cwd</span><span class="p">()</span>
        <span class="kd">let</span> <span class="nx">compiler</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Compiler</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">context</span><span class="p">)</span>
        <span class="nx">compiler</span><span class="p">.</span><span class="nx">options</span> <span class="o">=</span> <span class="nx">options</span>
        <span class="k">new</span> <span class="nx">NodeEnvironmentPlugin</span><span class="p">().</span><span class="nx">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span>
        <span class="k">if</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">plugins</span> <span class="o">&amp;&amp;</span> <span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">options</span><span class="p">.</span><span class="nx">plugins</span><span class="p">)){</span>
            <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">plugin</span> <span class="k">of</span> <span class="nx">options</span><span class="p">.</span><span class="nx">plugins</span><span class="p">){</span>
                <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">plugin</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">function</span><span class="dl">"</span><span class="p">){</span>
                    <span class="nx">plugin</span><span class="p">.</span><span class="nx">call</span><span class="p">(</span><span class="nx">compiler</span><span class="p">,</span> <span class="nx">compiler</span><span class="p">)</span>
                <span class="p">}</span><span class="k">else</span><span class="p">{</span>
                    <span class="nx">plugin</span><span class="p">.</span><span class="nx">apply</span><span class="p">(</span><span class="nx">compiler</span><span class="p">)</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">new</span> <span class="nx">WebpackOptionsApply</span><span class="p">().</span><span class="nx">process</span><span class="p">(</span><span class="nx">options</span><span class="p">,</span><span class="nx">compiler</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">compiler</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>
    <p>3.编译模块：每当检测到文件变化，一次新的Compilation将被创建。从Entry开始读取文件，根据文件类型和配置的Loader对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。（build-module：使用对应的Loader去转换一个模块；在用Loader对一个模块转换完后，使用acorn解析转换后的内容，输出对应的抽象语法树（AST），从配置的入口模块开始，分析其AST，当遇到require等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系。）</p>
  </li>
  <li>
    <p>4.封装代码块：根据入口和模块之间的依赖关系新增相应的chunk文件，把所有的模块中名称和此代码块名称一样的都放到这个chunk.modules中,确定好chunk内容，再把每个chunk转换成单独的资源文件加入到输出列表中。</p>
  </li>
  <li>
    <p>5.发射资源：根据配置确定输出的路径和文件名，把文件内容写入到文件系统。</p>
  </li>
</ul>

<h2 id="常用的loader">常用的loader</h2>
<ul>
  <li>file-loader: 把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li>
  <li>url-loader: 和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</li>
  <li>image-loader: 加载并且压缩图片文件</li>
  <li>babel-loader: 把 ES6 转换成 ES5</li>
  <li>css-loader: 加载 CSS，支持模块化、压缩、文件导入等特性</li>
  <li>style-loader: 把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS</li>
  <li>postcss-loader: 扩展 CSS 语法，使用下一代 CSS，可以配合 autoprefixer 插件自动补齐 CSS3 前缀</li>
</ul>

<h2 id="常用的plugin">常用的plugin</h2>
<ul>
  <li>html-webpack-plugin</li>
  <li>happypack</li>
  <li>clean-webpack-plugin</li>
  <li>purgecss-webpack-plugin：删除无用的css代码</li>
  <li>mini-css-extract-plugin：分离样式文件，CSS 提取为独立文件，支持按需加载</li>
</ul>

<h2 id="性能优化">性能优化</h2>
<ul>
  <li>1.删除无用的css样式</li>
  <li>2.图片压缩插件</li>
  <li>3.cnd加载文件</li>
  <li>4.tree-shakings &amp;&amp; scope hoisting</li>
  <li>5.dllplugin</li>
  <li>6.动态加载 import，原理是jsonp动态导入</li>
</ul>

<h2 id="webpack路由懒加载">webpack路由懒加载</h2>

<h2 id="webpack和gulp的使用以及区别">webpack和gulp的使用以及区别</h2>

<h2 id="webpack解决跨域的原理http-proxy-middleware代理中间件">webpack解决跨域的原理：http-proxy-middleware代理中间件</h2>

:ET