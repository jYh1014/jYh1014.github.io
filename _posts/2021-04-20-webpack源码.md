* any list
{:toc}

---
title: webpack源码
author: jyy
date: 2020-04-20 11:20:00 +0800
tags: [webpack]
pin: true
---

## **webpack源码之tapable**

- 要想了解webpack源码，那要提前了解一下其相关知识。比如插件的执行机制其实就是一种发布订阅的模式，在插件里面注册监听事件，然后在webpack源码里相应的时机去触发这个事件。

```js
const { SyncHook } = require("tapable")
const syncHook = new SyncHook(["name", "age"])
syncHook.tap("1", (name, age)=>{
    console.log(name, age)
})
syncHook.call("jyy", 20)

```

## **webpack源码之loader**

- 为什么需要loader？因为webpack运行在node环境中，只能识别js模块，对于css以及jsx后缀的文件以及图片它都不能识别，这个时候loader就出现了，它的存在就是为了解决这个问题。loader的作用就是能将源代码转化成webpack可识别的模块，也就是说loader最后输出的是一段js代码。
- 什么是loader？因为我们webpack所有的配置都是运行在node环境中，所以loader其实就是node模块，也就是说将来这个loader是要给webpack用的。那我们在自定义loader的时候就要注意一下要遵循commonjs规范，不能使用esm的语法。本质上一个loader模块导出的就是一个函数,看下面代码，这个就是一个最简单的loader。

```js
function loader(source) {
    //source是源文件代码，是字符串或者是buffer格式。
    return source
}
modules.exports = loader
```
- 一个真正的loader包含两部分，pitch函数和normal函数，一般pitch函数可以省略不写，我们举个例子来看一下pitch函数的存在对整个loader执行顺序的影响。我们自定义三个loader，loader1、loader2和loader3。然后在webpack配置里面加上这几个loader，要注意一下，默认情况下，webpack会去node_modules文件夹里面找loader，但是我们自定义的loader是在项目根目录下,需要配置一下resolveLoader。
```sh
├── dist
│   ├── app.js
│   └── index.html
├── loaders
│   ├── loader1.js
│   ├── loader2.js
│   └── loader3.js
├── package.json
├── src
│   ├── index.less
│   ├── main.js
│   └── test.js
└── webpack.config.js
```

```js
function loader1(source){
    console.log(source + "===loader1===")
}
module.exports = loader1
```
```js
function loader2(source){
    console.log(source + "===loader2===")
}
module.exports = loader2
```
```js
function loader3(source){
    console.log(source + "===loader3===")
}
module.exports = loader3
```
```js
//webpack.config.js文件
const path = require("path")
module.exports = {
    mode: "development",
    entry: {
        app: "./src/main.js"
    },
    output: {
        path: path.resolve(__dirname, "dist"),
        filename: "[name].js"
    },
    resolveLoader: {
        //如果在node_modules文件夹里面找不到，那就去loaders文件夹里面找
        modules: ["node_modules", path.resolve(__dirname,"loaders")]
    },
    module: {
        rules: [
            {
                test: /\.js$/,
                use: ["loader1","loader2","loader3"]
            }
        ]
    }
}

```
> 执行npm run build命令，看一下loader的输出顺序。loader3 -》loader2 -》loader1，也就是说是从右向左执行的。

```js
console.log(1);===loader3===
console.log(1);===loader2===
console.log(1);===loader1===
//console.log(1);这个是mian.js源文件内容。
```

> 上面的情况没有添加pitch，下面我们加上之后看看pitch函数以及loader（normal-loader）的执行顺序。pitch第一个参数的意思是剩下的loader，第二个参数是之前的loader，比如你在loader2的pitch函数中返回了某个值，那remainingRequest就是loader3，previousRequest就是loader1。

```js
function loader1(source){
    console.log(source + "===loader1===")
}
loader1.pitch = function(remainingRequest,previousRequest,data){
    console.log("===pitch1===")
}
module.exports = loader1
```
```js
function loader2(source){
    console.log(source + "===loader2===")
}
loader2.pitch = function(remainingRequest,previousRequest,data){
    console.log("===pitch2===")
}
module.exports = loader2
```

```js
function loader3(source){
    console.log(source + "===loader3===")
}
loader3.pitch = function(remainingRequest,previousRequest,data){
    console.log("===pitch3===")
}
module.exports = loader3
```

> build之后，看到输出结果是这样的,也就是说pitch函数是从左向右执行的。如果pitch函数有返回值的话，那就中断loader的执行，转而去执行上一个loader，还把返回值作为参数传给这个loader。
 
```js
===pitch1===
===pitch2===
===pitch3===
console.log(1);===loader3===
console.log(1);===loader2===
console.log(1);===loader1===
```
![diff](/assets/img/sample/webpackym-1.jpeg)
![diff](/assets/img/sample/webpackym-2.jpeg)

- loader分为4种，pre、normal、inline、post。优先级顺序就是pre、normal、inline、post。如果有pitch的话，那pitch的执行顺序和loader的相反。
```js
//webpack.config.js
{
    test: /\.js$/,
    enforce: "pre" ,
    use: ["pre-loader1", "pre-loader2"]
},
{
    test: /\.js$/,
    enforce: "post" ,
    use: ["post-loader1", "post-loader2"]
},
{
    test: /\.js$/,
    use: ["normal-loader1", "normal-loader2"]
},
```
```js
//main.js
import "inline-loader1!inline-loader2!./test.js" //行内loader
```
> build后结果如下

```js
===post1-pitch===
===post2-pitch===
===normal1-pitch===
===normal2-pitch===
===pre1-pitch===
===pre2-pitch===
pre-loader2
pre-loader1
normal-loader2
normal-loader1
post-loader2
post-loader1 //到这一行是对main.js文件进行loader解析的执行结果，下面是对test。js文件解析的结果
===post1-pitch===
===post2-pitch===
===inline1-pitch===
===inline2-pitch===
===normal1-pitch===
===normal2-pitch===
===pre1-pitch===
===pre2-pitch===
pre-loader2
pre-loader1
normal-loader2
normal-loader1
inline-loader2
inline-loader1
post-loader2
post-loader1
```
- 下面我们来具体写一个小例子,我们在main文件里引入test文件，我们想要拿到test文件导出的内容。
```js
//main.js
import a from "loader1!./test.js"
console.log(a)

//test.js
"我是test.js"
```
```js
function loader1(source){
    console.log(source + "===loader1===")
    return source
}
module.exports = loader1
```
> 如果我们这样写的直接输出source的话，那a的值就是空的。也就是说test文件并没有导出任何值。也就是说现在test文件被loader转化后内容是"test.js"，并没有任何导出的js代码。那我们加上导出代码改成下面这样试试。

```js
function loader1(source){
    console.log(source + "===loader1===")
    return `module.exports=${source}`
}
module.exports = loader1
```
> 这样test文件被转化成了“module.exports=test.js”，那我们import这个文件，就能拿到其导出的值就是“我是test.js”。也就是说，不管你是几个loader组合使用的，最后执行的那个loader输出的值要加上module.exports，不然别的模块将拿不到其导出值。

- 内联 loader 可以通过添加不同前缀，跳过其他类型 loader。

`!` 跳过 normal loader。
`-!` 跳过 pre 和 normal loader。
`!!` 跳过 pre、 normal 和 post loader。
