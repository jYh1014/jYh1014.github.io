I"t*<h2 id="iterator遍历器">iterator遍历器</h2>

<blockquote>
  <p>es6上是这样定义的：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作</p>
</blockquote>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>模拟一个遍历器生存函数
<span class="k">function </span>makeIterator<span class="o">(</span>arr<span class="o">){</span>
    <span class="nb">let </span>index <span class="o">=</span> 0
    <span class="k">return</span> <span class="o">{</span>
        next: <span class="k">function</span><span class="o">(){</span>
            <span class="k">if</span><span class="o">(</span>index &lt; arr.length<span class="o">){</span>
                <span class="k">return</span> <span class="o">{</span>
                    value: arr[index++],
                    <span class="k">done</span>: <span class="nb">false</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">{</span>
                    value: undefined,
                    <span class="k">done</span>: <span class="nb">true</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nb">let </span>it <span class="o">=</span> makeIterator<span class="o">([</span><span class="s2">"a"</span>,<span class="s2">"b"</span><span class="o">])</span>
console.log<span class="o">(</span>it.next<span class="o">())</span>
console.log<span class="o">(</span>it.next<span class="o">())</span>
console.log<span class="o">(</span>it.next<span class="o">())</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”.<br />
原生具备 Iterator 接口的数据结构如下:</p>
<ul>
  <li>Array</li>
  <li>Map</li>
  <li>Set</li>
  <li>String</li>
  <li>TypedArray</li>
  <li>函数的 arguments 对象</li>
  <li>NodeList 对象</li>
</ul>

<p>下面是为一个对象添加iterator接口的例子</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="nb">let </span>obj <span class="o">=</span> <span class="o">{</span>
  data: <span class="o">[</span> <span class="s1">'hello'</span>, <span class="s1">'world'</span> <span class="o">]</span>,
  <span class="o">[</span>Symbol.iterator]<span class="o">()</span> <span class="o">{</span>
    const self <span class="o">=</span> this<span class="p">;</span>
    <span class="nb">let </span>index <span class="o">=</span> 0<span class="p">;</span>
    <span class="k">return</span> <span class="o">{</span>
      next<span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span>index &lt; self.data.length<span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="o">{</span>
            value: self.data[index++],
            <span class="k">done</span>: <span class="nb">false</span>
          <span class="o">}</span><span class="p">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="k">return</span> <span class="o">{</span> value: undefined, <span class="k">done</span>: <span class="nb">true</span> <span class="o">}</span><span class="p">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span><span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span><span class="p">;</span>
<span class="k">for</span><span class="o">(</span><span class="nb">let </span>item of obj<span class="o">){</span>
    console.log<span class="o">(</span>item<span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="generator函数">generator函数</h2>

<blockquote>
  <p>在了解了回调函数和promise解决异步编程的不足之后，generator函数可以解决这些问题。
还有一种处理异步编程的方案叫做协程：意思是多个线程互相协作，完成异步任务。</p>
</blockquote>

<p>它的运行流程大致如下：</p>
<ul>
  <li>第一步，协程A开始执行</li>
  <li>第二步，协程A执行到一半，进入暂停，执行权转移到协程B</li>
  <li>第三步，（一段时间后）协程B交还执行权</li>
  <li>第四步，协程A恢复执行</li>
</ul>

<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。
Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）,yield命令是异步两个阶段的分界线。</p>

<p>下面看一个用Generator 函数来执行异步任务的例子：</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="nb">let </span>fetch <span class="o">=</span> require<span class="o">(</span><span class="s1">'node-fetch'</span><span class="o">)</span><span class="p">;</span>

<span class="k">function*</span> gen<span class="o">(){</span>
  var url <span class="o">=</span> <span class="s1">'https://api.github.com/users/github'</span><span class="p">;</span>
  var result <span class="o">=</span> yield fetch<span class="o">(</span>url<span class="o">)</span><span class="p">;</span>
  console.log<span class="o">(</span>result.bio<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
<span class="nb">let </span>g <span class="o">=</span> gen<span class="o">()</span><span class="p">;</span>
<span class="nb">let </span>result <span class="o">=</span> g.next<span class="o">()</span><span class="p">;</span>

result.value.then<span class="o">(</span><span class="k">function</span><span class="o">(</span>data<span class="o">){</span>
  <span class="k">return </span>data.json<span class="o">()</span><span class="p">;</span>
<span class="o">})</span>.then<span class="o">(</span><span class="k">function</span><span class="o">(</span>data<span class="o">){</span>
  g.next<span class="o">(</span>data<span class="o">)</span><span class="p">;</span>
<span class="o">})</span><span class="p">;</span>
可以看出虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便。
</pre></td></tr></tbody></table></code></pre></div></div>
<p>es6文档上指出thunk函数可以用于 Generator 函数的自动流程管理</p>
<h2 id="co模块">co模块</h2>

<blockquote>
  <p>用于 Generator 函数的自动执行，co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象</p>
</blockquote>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre>const fs <span class="o">=</span> require<span class="o">(</span><span class="s2">"fs"</span><span class="o">)</span>.promises

<span class="k">function*</span> <span class="nb">read</span><span class="o">()</span> <span class="o">{</span>
    <span class="nb">let </span>name <span class="o">=</span> yield fs.readFile<span class="o">(</span><span class="s2">"name.txt"</span>, <span class="s2">"utf8"</span><span class="o">)</span>
    <span class="nb">let </span>age <span class="o">=</span> yield fs.readFile<span class="o">(</span>name, <span class="s2">"utf8"</span><span class="o">)</span>
    <span class="nb">let </span>xx <span class="o">=</span> yield <span class="o">{</span> a: age + 20 <span class="o">}</span>
    <span class="k">return </span>xx
<span class="o">}</span>
co<span class="o">(</span><span class="nb">read</span><span class="o">)</span>.then<span class="o">(</span>data <span class="o">=&gt;</span> <span class="o">{</span>
    console.log<span class="o">(</span>data<span class="o">)</span>
<span class="o">})</span>
//源码实现如下：
<span class="k">function </span>co<span class="o">(</span>gen<span class="o">)</span> <span class="o">{</span>
    <span class="nb">let </span>self <span class="o">=</span> this
    <span class="k">return </span>new Promise<span class="o">((</span>resolve, reject<span class="o">)</span> <span class="o">=&gt;</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span>typeof gen <span class="o">===</span> <span class="s2">"function"</span><span class="o">)</span> <span class="o">{</span>
            gen <span class="o">=</span> gen.call<span class="o">(</span>self<span class="o">)</span>
        <span class="o">}</span>
        <span class="k">function </span>next<span class="o">(</span>data<span class="o">)</span> <span class="o">{</span>
            <span class="nb">let</span> <span class="o">{</span> value, <span class="k">done</span> <span class="o">}</span> <span class="o">=</span> gen.next<span class="o">(</span>data<span class="o">)</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">done</span><span class="o">)</span> <span class="o">{</span>
                resolve<span class="o">(</span>value<span class="o">)</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                Promise.resolve<span class="o">(</span>value<span class="o">)</span>.then<span class="o">(</span>data <span class="o">=&gt;</span> <span class="o">{</span>
                    console.log<span class="o">(</span>data<span class="o">)</span>
                    next<span class="o">(</span>data<span class="o">)</span>
                <span class="o">}</span>, err <span class="o">=&gt;</span> console.log<span class="o">(</span>err<span class="o">))</span>
            <span class="o">}</span>

        <span class="o">}</span>
        next<span class="o">()</span>
    <span class="o">})</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
:ET