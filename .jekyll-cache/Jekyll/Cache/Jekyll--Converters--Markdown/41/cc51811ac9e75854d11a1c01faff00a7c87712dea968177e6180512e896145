I"<p><strong>1.模块化发展历程</strong></p>
<blockquote>
  <p>命名空间模式 -》 自执行函数 -》commonjs -》amd -》umd -》cmd -》esm</p>
</blockquote>

<p><strong>2.为什么需要模块化</strong><br />
1.团队多人协作，需要引用别人的代码
2.项目交接，我们在阅读和重构别人的代码
3.不同的环境，环境变量不同</p>

<p>基于以上场景，当前js模块化主要有以下几个目的：
1.防止污染全局作用域
2.代码复用性和可维护性
3.功能代码松耦合
4.解决依赖关系不明显的问题</p>

<p><strong>3.命名空间模式</strong></p>

<blockquote>
  <p>这种方式”污染”了全局变量，这样的写法会暴露所有模块内的成员，内部状态可以被外部改写</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre><span class="kd">var</span> <span class="nx">mathUtils1</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">add</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">var</span> <span class="nx">mathUtils2</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">add</span><span class="p">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">,</span> <span class="nx">z</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">x</span> <span class="o">+</span> <span class="nx">y</span> <span class="o">+</span> <span class="nx">z</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="nx">mathUtils</span><span class="p">.</span><span class="nx">add</span><span class="p">();</span>
<span class="nx">mathUtils</span><span class="p">.</span><span class="nx">square</span><span class="p">();</span>

</pre></td></tr></tbody></table></code></pre></div></div>
<p><strong>4.自执行函数模式</strong></p>
<blockquote>
  <p>可以达到不暴露私有成员的目的,但是依赖关系不明显。</p>
</blockquote>

<p><strong>5.commonjs模式</strong></p>
<blockquote>
  <p>优点：解决了依赖、全局变量污染的问题.
缺点：1.CommonJS用同步的方式加载模块，在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，js线程会阻碍ui线程，造成页面卡顿，CommonJS不适合浏览器端模块加载，更合理的方案是使用异步加载。
2.CommonJS模块加载的是输出值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。
3.模块加载一次后值会被缓存起来。
4.运行时加载。</p>
</blockquote>

<p><strong>6.amd模式（requirejs）</strong></p>

<blockquote>
  <p>异步并行加载模块；所有模块加载完成后再执行回调函数.依赖前置（不管是否用到这些模块，都必须提前声明好，也就是提前加载完成。</p>
</blockquote>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="nx">require</span><span class="p">([</span><span class="dl">"</span><span class="s2">./modules/a</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">./modules/b</span><span class="dl">"</span><span class="p">],</span> <span class="kd">function</span> <span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span>
<span class="p">})</span>
<span class="nx">define</span><span class="p">(</span><span class="kd">function</span> <span class="p">()</span> <span class="p">{</span>
    <span class="kd">function</span> <span class="nx">add</span><span class="p">(</span><span class="nx">a</span><span class="p">,</span> <span class="nx">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">a</span> <span class="o">+</span> <span class="nx">b</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">{</span> <span class="nx">add</span> <span class="p">}</span>
<span class="p">});</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>7.umd模式（requirejs）</strong></p>

:ET