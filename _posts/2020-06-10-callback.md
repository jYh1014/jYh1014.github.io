---
title: callback
author: jyy
date: 2020-06-10 9:20:00 +0800
# categories: [Blogging, Tutorial]
tags: [js]
pin: true
---

## callback

> 定义：一个函数作为另一个函数的参数

## 应用场景
1.传参

```sh

//1）方法1，利用call解决
//a.js文件
function fun2(){
    console.log(this)
    this.fun1("jyy")
}
module.exports = fun2

//b.js文件

let fun2 = require("./8.callback.js")
let obj = {
  name: "123",
  fun1: function(name){
    obj.name = name
  }
}
//此处用call来更改this指向，不然a文件fun2函数里面的this指向global，并不是obj。
fun2.call(obj) 
console.log(obj.name)

//2）方法2,利用回调函数解决
//a.js文件
function fun2(callback){
    callback("jyy")
}
module.exports = fun2
//b.js文件

let fun2 = require("./8.callback.js")
let obj = {
  name: "123",
  fun1: function(name){
    obj.name = name
  }
}
fun2(obj.fun1) 
console.log(obj.name)
```

2.函数的组合
- before

 ```sh
const say = (...args) => {
    console.log("说话", ...args);
}
Function.prototype.before = function(fn){
    
    // this say

    return (...args) => {
      fn();
      this(...args);
    }
}
const newfun = say.before(() => { 
    console.log('你好') ;
})

newfun(1,2,3);

//结果是 你好 说话 123
 ```
- after

```sh
let fun = function(times, fn){
    return () => {
        console.log(times)
        if(--times === 0){
            fn();
        }
    }
}

const newafter = fun(3, function(){
    console.log("三次后执行")
})
newafter()
newafter()
newafter()
```
- 事务 开始的时候做某件事，结束的时候做某件事

```sh
const perform = function (fn, wrapper) {
    wrapper.forEach(w => {
        w.init();
    })
    fn();
    wrapper.forEach(w => {
        w.close();
    })
}
perform(function () {
    console.log("说话")
}, [
    {
        init: function () {
            console.log("你好")
        },
        close: function () {
            console.log("再见")
        }
    },
    {
        init: function () {
            console.log("你好1")
        },
        close: function () {
            console.log("再见1")
        }
    }
])
```
- all(并发的问题可以用计数器解决)

```sh
let fs = require("fs");
let school = {}
let after = function(times, fn){
    fn()
}
let newafter = after(2, function () {
    console.log(school)
})
fs.readFile("name.txt", "utf8", (err, data) => {
    school["name"] = data;
    # newafter();
})
fs.readFile("age.txt", "utf8", (err, data) => {
    school["age"] = data
    # newafter();
})
//由于fs.readFile是异步的，fn先执行，所以school的值是{}
//可以用计数器来解决
let after = function (times, fn) {
    return () => {
        if (--times == 0) {
            fn();
        }
    }
}
let newafter = after(2, function () {
    console.log(school)
})
fs.readFile("name.txt", "utf8", (err, data) => {
    school["name"] = data;
    newafter();
})
fs.readFile("age.txt", "utf8", (err, data) => {
    school["age"] = data
    newafter();
})
```

- 柯里化

> 定义：就是将一个函数拆分成多个函数（把一个多参数的函数，转化为单参数函数）

```sh
function add(a, b, c) {
    return a + b + c
}
function curry(fn, arr = []) {
    return (...args) => {
        arr = arr.concat(args)
        let len = fn.length
        if (arr.length < len) {
            return curry(fn, arr)
        } else {
            return fn(...arr)
        }
    }
}
let r = curry(add)(1)(2)(3)
console.log(r)
```
