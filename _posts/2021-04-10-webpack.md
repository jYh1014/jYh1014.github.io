* any list
{:toc}

---
title: webpack
author: jyy
date: 2020-04-10 15:20:00 +0800
tags: [webpack]
pin: true
---

## **webpack基本配置**

#### **webpack基本配置(一)**
- 首先，我配置的这个react版本的webpack，是参考的vue-cli2里面的配置，cli2版本的webpack配置是暴露出来的，而cli3版本的配置没有暴露。首先我们来初始化一个vue-cli2项目来看一下目录结构是怎么样的。

```sh
├── README.md
├── build
│   ├── build.js                    #生产环境执行的文件node build.js
│   ├── check-versions.js
│   ├── logo.png
│   ├── utils.js                    #工具方法
│   ├── vue-loader.conf.js          #vue-loader配置文件
│   ├── webpack.base.conf.js        #webpack公共配置
│   ├── webpack.dev.conf.js         #dev开发环境环境配置
│   └── webpack.prod.conf.js        #production生产环境配置
├── config
│   ├── dev.env.js                  #定义开发环境变量
│   ├── index.js                    #基础变量的定义
│   └── prod.env.js                 #定义生产环境变量
├── index.html                      #html模版文件
├── package.json  
├── src
│   ├── App.vue
│   ├── assets                      #一般是存放开发中自己写的静态资源（css、img、js等）
│   ├── components                  #业务组件
│   │   └── HelloWorld.vue
│   └── main.js                     #入口文件
└── static                          #一般存放第三方的静态资源（jquery.js等）
    └── logo.png
```
- cli2版本的webpack使用的还是3.x版本，现在我们把webpack升级到4.x版本。里面具体的包的升级版本方案可以参考[https://juejin.cn/post/6844903798645719047/](https://juejin.cn/post/6844903798645719047/)这篇文章。
- cli2是支持vue框架的，但是并不支持react框架。我们接下来要把升级后的cli改造成支持react的。
    - 首先，因为react是用jsx语法编写项目的，在react项目里，后缀是.js的文件，其实全称都是.jsx。我们要能够解析也就是识别这种jsx文件，也就是说需要一个loader来解析这种文件。loader的作用就是将源文件做一下转化，会将es5以上的高级语法进行转义，转义成浏览器能够识别的es5。其实也就是babel-loader能做到这件事情。cli2版本里面已经配置了，所以我们不用额外处理。
    - 其次，还要在.babelrc配置文件中配置一下babel，其中@babel/preset-react是解析react语法的，而babel必须要和@babel/preset-env结合使用。
    ```sh
    {
    "presets": ["@babel/preset-env", "@babel/preset-react"]
    }
    ```
- 到此，一个支持react的cli就配置好了。下一节让我们按照升级版vue-cli的配置从零开始搭建一个webpack。

#### **webpack基本配置(二)**

- 第一步，我们的目录结构要保持和cli版本的一致。
```sh
├── build
├── config
├── index.html
├── package-lock.json
├── package.json
├── src
│   ├── App.js
│   ├── components
│   └── main.js
└── static
```
- 第二步，把cli版本的package.json复制过来，安装包。
- 第三步，分别配置开发环境和生产环境。为什么要区分这两个环境？首先开发环境是给本地开发人员在开发过程中方便开发以及调试的环境；而生产环境是发布到线上给用户使用的环境。虽然这两个环境都是通过同一套源代码编译而来，但是编译之后的内容却不一样。比如开发过程中输出的一些日志，生产环境中就尽量不要出现；线上代码一般还会经过压缩处理；
    - 定义环境变量来区分环境。生产环境的入口文件是在build文件夹下的build.js文件，其实这个文件我们可以先复制cli里的。里面代码别的好像有很多不懂的，但是最上面有一句很关键的设置环境变量的。接下来我们就能通过这个process.env.NODE_ENV变量在webpack配置中来区分环境了，注意，这里我们来区分环境只是在webpack配置文件里能拿到这个变量的值，是因为webpack的这些配置文件是运行在node环境下，也就是说在你的业务代码组件中是不能拿到这个变量值的。当然也有办法可以解决，详情后续会介绍。
    ```sh
    process.env.NODE_ENV = 'production'
    ```
    - 把cli里面的config文件内容也复制过来，里面用到的内容后续会说明。
    - 开发环境和生产环境的配置也会有一些公共的配置，我们把这些公共配置提取出来放到base文件里。然后在不同的环境下我们用webpack-merge这包来解决合并的问题。这一步我们就先编写base文件
    ```sh
    module.exports = {
        context: path.resolve(__dirname, '../'), //上下文context，一般都是当前项目的根目录，这个会影响entry文件引入的相对地址是相对于什么，其实就是相对于context。
        entry: {
            app: "./src/main.js" //入口文件
        },
        output: {
            path: config.build.assetsRoot, //将来打包生成的文件会放到哪个位置，其实就是根目录下的dist文件夹
            filename: "[name].js", //“app.js”
            publicPath: process.env.NODE_ENV === "production" ? config.build.assetsPublicPath : config.dev.assetsPublicPath  //关于publicpath后续我们会细讲，在此先不做说明。
        },
        module: {
            rules: [
                {
                    test: /\.jsx?$/,
                    loader: "babel-loader",
                    exclude: /node_modules/
                },
                {
                    test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,
                    loader: 'url-loader',
                    options: {
                        limit: 10000, //当图片大小不超过这个值的时候，将会经过url-loader处理，转化为base64格式的图片打包到app.js里。
                        name: 'img/[name].[hash:7].[ext]'
                    }
                },
                {
                    test: /\.(mp4|webm|ogg|mp3|wav|flac|aac)(\?.*)?$/,
                    loader: 'url-loader',
                    options: {
                        limit: 10000,
                        name: utils.assetsPath('media/[name].[hash:7].[ext]')
                    }
                },
                {
                    test: /\.(woff2?|eot|ttf|otf)(\?.*)?$/,
                    loader: 'url-loader',
                    options: {
                        limit: 10000,
                        name: utils.assetsPath('fonts/[name].[hash:7].[ext]')
                    }
                }
            ]
        }
    }
    ```
    - 开始配置开发环境，首先要考虑的地方是本地开发你怎么打开页面来调试？第一个点就是要在本地开启一个服务器，也就是devserver。
    然后你打开的页面是怎么来的呢？webpack只是把所有的文件模块按照规则打包了起来，这些将来都要插入到html里面。而这个html需要通过html-webpack-plugin这个插件来帮你自动生成html页面。
    其次就是要开启热更新模式，让开发人员在修改文件代码的时候不要重新刷新页面。再然后就是用相应的loader来解析样式文件。
    下面我们看看webpack.dev.conf.js文件的内容

    ```sh
    const merge = require('webpack-merge')
    const webpack = require('webpack')
    const path = require("path")
    const config = require("../config")
    const utils = require('./utils') //utils文件里是针对样式文件处理的loader
    const baseWebpackConfig = require('./webpack.base.conf')
    const HtmlWebpackPlugin = require('html-webpack-plugin')
    const CopyWebpackPlugin = require('copy-webpack-plugin')

    const devWebpackConfig = merge(baseWebpackConfig, {
    mode: "development",
    module: {
        rules: utils.styleLoaders({ sourceMap: config.dev.cssSourceMap, usePostCSS: true })
    },
    devServer: {
        hot: true, //开启热更新
        host: config.dev.host, //本地访问的主机名，如果设置成0.0.0.0那么在同一个局域网内，别人也能通过ip访问你的页面。
        port: config.dev.port, //端口号
        publicPath: config.dev.assetsPublicPath,
        historyApiFallback: { //history模式的路由，出现404的话将重定向到首页。
            rewrites: [
                { from: /.*/, to: path.posix.join(config.dev.assetsPublicPath, 'index.html') },
            ],
        },
        proxy: config.dev.proxyTable, //反向代理，比如你请求的是localhost:8080/api/getdata,其实最后请求的是某台服务器里面的http:///erp.test.com/api/getdata
        hotOnly:true
    },
    plugins: [
        new webpack.DefinePlugin({
        'process.env': require('../config/dev.env')
        }),
        new webpack.HotModuleReplacementPlugin(), //开启热更新
        new HtmlWebpackPlugin({
        filename: 'index.html',
        template: path.resolve(__dirname, "../public/index.html"),
        inject: true, //表示在body底部插入js文件
        chunksSortMode: 'none'
        })
    ]
    })
    module.exports = devWebpackConfig
    ```
    - 最后配置生产环境，我们先只考虑压缩这一个功能，别的我们后续根据需求做细讲。

    ```sh
    const env = require("../config/prod.env")
    const utils = require('./utils')
    const config = require('../config')
    const webpack = require("webpack")
    const HtmlWebpackPlugin = require("html-webpack-plugin")
    const merge = require('webpack-merge')
    const baseWebpackConfig = require('./webpack.base.conf')
    const path = require("path")
    process.env.NODE_ENV = 'production'


    const webpackConfig = merge(baseWebpackConfig, {
        mode: "production",
        output: {
            path: config.build.assetsRoot,
            filename: utils.assetsPath('js/[name].[chunkhash].js'),
            chunkFilename: utils.assetsPath('js/[name].[chunkhash].js') //chunk包的名字
        },
        module: {
            rules: utils.styleLoaders({
                sourceMap: config.build.productionSourceMap,
                extract: true,
                usePostCSS: true
            })
        },
        devtool: config.build.productionSourceMap ? config.build.devtool : false,
        plugins: [
            new HtmlWebpackPlugin({
                filename: 'index.html',
                template: path.resolve(__dirname, "../public/index.html"),
                inject: true, //表示在body底部插入js文件
                minify: {
                    removeComments: true, //清理注释
                    collapseWhitespace: true, //清理换行符 空格
                    removeAttributeQuotes: true //移除属性的引号
                    // more options:
                    // https://github.com/kangax/html-minifier#options-quick-reference
                },
                chunksSortMode: 'none'
            }),
        ]
    })
    if (config.build.productionGzip) {
        const CompressionWebpackPlugin = require('compression-webpack-plugin')

        webpackConfig.plugins.push(
            new CompressionWebpackPlugin({
                asset: '[path].gz[query]',
                algorithm: 'gzip',
                test: new RegExp(
                    '\\.(' +
                    config.build.productionGzipExtensions.join('|') +
                    ')$'
                ),
                threshold: 10240,
                minRatio: 0.8
            })
        )
    }
    module.exports = webpackConfig
    ```
## **webpack优化**

- 说到优化，我们得先了解http相关知识
- 首先每次资源请求服务器都会建立http链接，涉及到tcp的三次握手。（http1。2版本之后就是长链接，不用每次都建立http链接，所以这个重新建立链接的时间不需要考虑了），但是每次从请求到响应结束都是需要耗时一定时间的，也就是说总的请求数越少，那总体项目的耗时就越少。这个我们可以通过缓存来优化，也可以通过合并图片合并脚本以及合并css来优化
- 因为http对同一域名的并发请求数在http1.1版本下最多是六个，也就是说其余的请求将会被堵塞。只有这六个请求执行完毕，才会继续执行其余的请求。所以我们尽量要避免出现大体积的文件，这个我们可以通过按需加载来优化处理，也可以通过分包的规则来优化处理，比如一个包500kb，而其余的5个包都是50kb，那就要等到这个500kb的包响应结束才能继续往下进行http请求，我们可以把这个500kb的包拆分出来一部分，分成200kb和300kb，这样性能就好了一些。如果真的优化不了体积大小，那就将文件置于页面底部最后请求，这样不至于堵塞。
#### **webpack优化之缓存系列**
- 缓存只是针对生产环境来做的优化，来提高性能，节省带宽，也就是说减少请求服务器的静态资源的数量。内容不变的情况下去缓存里取资源，内容变了再去请求服务器
- 提前需要知道什么是chunk文件？首先webpack的编译会先从入口文件开始解析，然后寻找和其依赖的文件，来构建对应的chunk文件。举个例子看一下。新建两个组件页面Home.js和Lazy.js。我们在Home.js文件里面按需引入了一个Lazy组件。来直接先看一下构建的结果

```js
//App.js
import React from "react"
import ReactDOM from "react-dom"
import "./components/Home"

export default function App(props) {
  return (
    <div>
        我是app页面
    </div>
  )
}
```

```js
//Home.js
import React from "react"
import ReactDOM from "react-dom"
import(/* webpackChunkName: "lazy" */"./Lazy.js").then(res=>console.log(res))
```

```js
//Lazy.js
console.log("lazy")
```
![diff](/assets/img/sample/webpack-1.png)
我们看到最终构建生成的有两个chunk文件，一个是app.js文件，一个是lazy.js文件。app.js就是根据入口文件来打包生成的chunk，而lazy.js是按需加载引入的那个Lazy.js文件打包生成的chunk。
- 我们的资源都是在index.html页面中通过script标签或者stype标签引入的，也就是说如果我们不想通过跟服务器通信的方式来获取资源，也就是说强制浏览器使用本地缓存，那html引用的资源链接只有没有变化的才会走本地缓存，通常这个链接会有一个版本标记也就是hash标记，这个hash值是根据文件的内容来进行的摘要算法，也就是说文件内容不变，hash也就不会变。比如每次修改一个文件，不管这个打包出来的chunk有没有被修改，所有的chunk文件都去重新请求服务器，这样花费的时间就要长一点。按照正常情况下，你修改了这个chunk文件，那应该去重新请求服务器获取资源，但是如果你没有修改，那应该直接从缓存里面取而不是去再次请求服务器会合理一些，而且这样也会节省时间。也就是说没变更的chunk要走缓存，变更的chunk要去请求服务器。这个变更我们是从chunk的粒度来解释说明的。再举个例子，有3个css文件分别是a.css,b.css,c.css，其中a.css内容变更了，另外两个没变，那就只有a.css走本地缓存。这个粒度就是文件级别的，也就是说粒度越小越精准。
- 在具体举例子说明之前还要先介绍几种hash的区别，因为缓存靠的就是hash值是否变化。
    - hash：每次项目的构建都会生成一个hash值，只要项目里面有任何一个文件内容做了修改，那这个hash值就会变。如果全部文件都用这个hash值的话，那就做不了缓存。
    - chunkhash：是根据chunk内容生成的hash值，只有chunk文件包含的内容发生改变，hash才会变。这样也会有一个问题，如果我们只修改了js文件，没有修改css文件，那css文件的hash不变才合理，只有chunk文件的hash会变，但是由于css是在js文件中引入的，是js的依赖项。所以css文件和chunk文件的hash值会相同。此时我们就应该想办法让css的hash值不变，也就是说让粒度小一点这样才精准。于是就有了contenthash。
    - contenthash：根据css文件内容生成的hash，只要css文件内容不变，那hash值就不会变。

> 下面我们先举第一个例子，如果打包出来的所有文件的文件名的方式是[name].[hash].js或者[name].[hash].css

![diff](/assets/img/sample/webpack-2.png)

> 可以看到这个图片最上面有个hash值：bd5b482bc1ce412ac0d2，然后仔细观察每个打包出来的文件名里面也都有同样的hash，就是所有的文件hash值都相同。接下来我们随便修改一个文件内容，比如app.js。再次build一下，可以看到所有文件的hash值都变了，这并不是我们想要的结果。

![diff](/assets/img/sample/webpack-3.png)

> 然后我们举第二个例子，如果打包出来的所有文件的文件名的方式是[name].[chunkhash].js或者[name].[chunkhash].css

![diff](/assets/img/sample/webpack-4.png)

> 可以看到所有文件的**hash**值跟这个构建的最上面的hash值并不相同。这个时候我们同样修改一下app.js文件，再次build看看

![diff](/assets/img/sample/webpack-5.png)
> 从上面图片可以看到修改了app文件，chunk app文件的hash变了，但是css文件的hash值也跟着变了，这个不是想要的结果。这个时候就要给css文件划分更小的粒度，就是说判断css 的chunk hash变化的依据是css文件的内容有没有变。引入contenthash就能达到这个目的了。然后我们来举第三个例子，把打包css文件的名称方式改为[name].[contenthash].css，build一次看看效果。

![diff](/assets/img/sample/webpack-6.png)

> 然后修改app.js文件，再次build。

![diff](/assets/img/sample/webpack-7.png)

> 此时发现只有chunk app文件的hash值发生来改变，这个才是我们的目的。接下来我们修改lazy.js文件build一下看看现象。

![diff](/assets/img/sample/webpack-8.png)

> 结果和我们预想的不太一样，我们会以为chunk app的hash不会改变，只有chunk lazy的hash变了，但现象不是这样的，它俩都变了。其实自己先简单的思考一下，引起hash变化的原因只有是文件内容发生了变化，也就是说修改了lazy文件，会引起chunk app的内容发生变化，又想到lazy文件本身是打包在chunk lazy文件中并没有包含在chunk app文件中。思考到这里，我们要先了解optimization.runtimeChunk的作用。我们先简单的配置一下optimization的分包规则,然后build来看看效果。

```sh
 optimization: {
    minimize: true,
    runtimeChunk: { name: 'runtime' }
}
```
![diff](/assets/img/sample/webpack-9.png)

> 可以看出多出来一个runtime的chunk文件，然后我们再修改lazy.js文件，再build看看效果。

![diff](/assets/img/sample/webpack-10.png)

> 惊奇的发现竟然只有chunk lazy文件和runtime文件的hash值发生了变化，这个正好满足我们的需求。那我们就来具体的分析一下为什么配置了optimization.runtimeChunk，就能达到目的了？

- runtimeChunk看名字直白一点的翻译大概就是运行时的chunk文件，那么什么是运行时代码？其实就是我们通过异步加载的代码比如import("./lazy.js")这种就是运行时代码。本来我们的chunk app文件里面会有一段对chunk lazy文件的映射关系列表，当lazy文件修改了，这个映射的文件名也要变化，那自然会引起chunk app文件内容的变化，所以我们要把这段映射关系提取出来。runtimeChunk做的就是这个事情，但是每次修改lazy文件后都会引起runtime文件hash值的变化，会导致去重新请求服务器，而且打包出来的这个runtime文件很小，就是http请求的时间比执行这个文件更耗时，建议不要单独拆包，可以内敛进html里，关于内敛可以使用插件html-webpack-inline-source-plugin来实现，这里不做介绍。

- 到此为止，缓存系列的知识先介绍到这里。

#### **webpack优化之分包系列**

- 为什么要分包？这个在最开始的时候提到过，一个原因是http对同一域名的并发请求数最大是6个，超过这个数量，别的请求将会处于堵塞状态。浏览器要等这6个请求全部执行完才能继续往下发起请求。如果其中一个包的体积很大，执行时间很长，那浏览器就会堵塞，我们可以把这个包拆分出来一些。还有另外一个原因，跟缓存有关，我们经常修改的代码是自己的业务代码，但是第三方库是不用频繁变动的而且最重要的是第三方库的体积很大，如果我们将第三方库也和app打包在一起，那等于第三方库也要经常去服务器请求资源，这样会很耗费时间。我们可以把第三方库单独拆分出来打成一个包，这样当修改自己的业务代码时，就不用再次去向服务器重新请求第三方库的资源，而是去缓存里取。
- 分包规则的配置主要就是利用webpack4内置的optimization来完成的。再进行具体的分包规则之前，我们要安装一个关于性能分析的插件webpack-bundle-analyzer，配置好之后我们通过npm run build --report命令来看看效果
```js
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin
webpackConfig.plugins.push(new BundleAnalyzerPlugin())
```

![diff](/assets/img/sample/webpack-11.png)

> 可以看到app里面包含了第三方库的代码，现在我们将第三方库提取出来

```js
optimization: {
    minimize: true,
    splitChunks: {
         // 默认值是30kb 当文件体积 >= minsize 时将会被拆分为两个文件 某则不生成新的chunk
        minSize: 30000,
        cacheGroups: {
            vendors: {
            test: /[\\/]node_modules[\\/]/,
            chunks: 'initial', //表示从同步模块代码中提取，“async”表示从异步模块代码中提取，“all”是所有的模块。
            name: 'vendors',
            },
        },
    },
    runtimeChunk: { name: 'runtime' }
},
```
> 配置完成后，npm run build --report看看效果

![diff](/assets/img/sample/webpack-12.png)

> 可以看到多了一个vendors的包，这个包就是我们从app里面提取出来的第三方库的资源。其实如果项目中如果还有一些公共的工具方法的话，一般也都会提取出来。下面我们来举个例子，在static文件夹下面新增一个工具函数sea.js,然后分别在app.js和lazy.js文件中都引入这个文件。然后build看看效果。

![diff](/assets/img/sample/webpack-13.png)

> 从上面图片可以看到，即使我们在app.js和lazy.js文件中都引入了这个相同的文件，但是最后只打包进 chunk app文件里了，在chunk lazy文件并没有这个，说明虽然多个文件引入相同的资源，但是并不会重复打包，注意我们此刻测试的是分别在同步模块和异步模块都引入相同的资源的情况。接下来我们再举个例子，我们再新建个lazy1.js，然后在Home.js文件中按需引入,并且lazy1文件也要引入sea.js文件，去掉app.js文件对seajs的引用。然后build。

```js
//Home.js
import React from "react"
import ReactDOM from "react-dom"
import(/* webpackChunkName: "lazy" */"./Lazy.js").then(res=>console.log(res))
import(/* webpackChunkName: "lazy1" */"./Lazy1.js").then(res=>console.log(res))

//Lazy1.js
import "../../static/sea"
console.log("lazy1")
```
![diff](/assets/img/sample/webpack-14.png)

> 从上面图片中我们看到，在异步模块lazy和lazy1都引入了相同的文件，会导致重复打包的，我们需要把这个公共文件也提取出来。

```js
optimization: {
    minimize: true,
    splitChunks: {
            // 默认值是30kb 当文件体积 >= minsize 时将会被拆分为两个文件 某则不生成新的chunk
        minSize: 30000,
        cacheGroups: {
            vendors: {
                test: /[\\/]node_modules[\\/]/,
                chunks: 'initial', //
                name: 'vendors',
            },
            'async-vendors': {
                test: /[\\/]node_modules[\\/]/,
                minChunks: 2, //表示该公共模块被共享的chunk文件的数量，只有>= 2才能被提取出来
                chunks: 'async', //表示从异步模块中提取
                name: 'async-vendors'
            }
        },
    },
    runtimeChunk: { name: 'runtime' }
},
```
> 如果公共模块的体积很小，比如就1kb，把这个模块提取出来会增加一次向服务器请求资源的耗时，也就是本来lazy是5kb，lazy1也是5kb，然后拆分出来1kb，你要衡量一下1kb的东西值得单独打包吗？到此为止分包就介绍完了。

#### **webpack优化之按需加载**

- 为什么需要按需加载？这个是从减少包的体积方面来优化的，对首屏优化很重要。如果我们把所有的组件都打包到app chunk文件中，不管在首屏页面中有没有使用到这个组件，这样就是浪费了带宽和流量也增加了请求的耗时，因为里面很多组件我们并不需要在首屏显示。比如我们在首屏页面不需要展示lazy组件的内容，我们只有在某个路由下才会展示这个组件，也就是说只有在某个路由下我们再去请求这个lazy文件，不在首屏去请求，那自然也就减少了chunk app文件的大小，这样会对首屏的性能有不少的提高。上面我们举的lazy组件其实就是按需加载的方式，他会单独生成一个chunk文件。
- 按需加载有几种方式：
    - 异步路由
    - 第三方模块按需引入，比如lodash，antd等等这些常用的又比较大的包。
- 异步路由的方式react官网上有配置。大致原理也是用import()这种方式引入的组件
- 我们主要来讲一下第三方库按需引入的配置方法。首先要思考一下为什么第三方库还需要特殊的配置？我们不能直接import {Button} from "antd"通过这种方式引入吗，这样为什么就不是按需加载了呢？其实这个和tree shaking的原理有关。tree shaking意思是摇树，它是在静态分析阶段也就是编译阶段对js文件进行分析，然后删除无用的代码。注意一个关键的地方就是静态分析，那么commonjs模块能做到静态分析？esm能做到静态分析？这就和模块化有关。只有esmodule能做到静态分析。也就是说我们引入的方式要按照esm的方式，而且别人导出的方式也要是esm的方式。那么问题来了，我们编写的业务组件都会被webpack识别为模块进行babel编译为es5，如果是这样的话那么我们项目将使用不了摇树的功能。所以我们需要在babel的配置文件里做以下配置。"modules": false，就是让babel先别将es6编译为es5。而且还有一个问题，人家第三方库并不一定就是按照esmodule方式开发的，这个时候，就需要引入插件来支持按需加载。
- 下面我们来安装一下antd。并且在app.js文件中引入一个button组件。然后build一下，

![diff](/assets/img/sample/webpack-15.png)

> 从上面图中我们看到antd只加载了button这一个组件，也就是说本身就支持了按需引入，这里我用的是antd@3.x版本。那么下面我们继续引入另外一个包lodash，这个包在开发过程中也是必不可少的。我们在home组件import { debounce } from "lodash"，然后build看看。

![diff](/assets/img/sample/webpack-16.png)

> 从上面图中发现lodash包的大小竟然有530kb，这个不太正常，应该是没有做到按需引入。此时我们可以去查一下相关的文章，配置一下按需加载。具体配置过程不做详细介绍。然后我们继续引入jquery。然后build一下看看

![diff](/assets/img/sample/webpack-17.png)

> 从上面图中发现jq文件不小，但是好像也没有明显的能具体优化的点，这个时候我们只能试着找一下有没有能够替代jq的第三方库，有一个zepto库基本能包括jq的常用功能，我们可以用这个zepto代替jq。另外如果我们在 项目中不想多次引入jq，想直接使用$，就是类似把jq挂在了window下的意思。也有相应的办法解决。

## **webpack配置之publicpath**

- 首先我们先谈一下output里面的publicpath，它的作用到底是什么？我们先看个例子，初始化的时候publicpath的默认值是“/”，我们build一下看看。

![diff](/assets/img/sample/webpack-18.png)
![diff](/assets/img/sample/webpack-19.png)

> 这个是build后index.html页面引入的静态资源的路径，而且页面资源也都可以正常获取到。“/static/js/vendors.78e9b81c3b71ae038bb6.js”但是这个“/”又代表了什么意思呢？这个路径的完整路径又是什么呢？
- 接下来我们修改output里面的publicpath：“/abc/”，然后再次build。

![diff](/assets/img/sample/webpack-20.png)
![diff](/assets/img/sample/webpack-21.png)

> 此时页面出现白屏了，说明没有找到对应的资源，也就是说资源路径不对。“http://localhost:8081/abc/app.js”这个路径下并没有这个文件，那如果想要在目录下能够正常访问到这个文件应该怎么做呢？app.js文件和html页面是在同一层级的，也就是相对的，我们现在访问的页面是localhost：8080/index.html,这个路径下只能访问localhost：8080/app.js是可以正常访问的，但是localhost：8080/abc/app.js就不能访问到，那我们在页面访问路径后面加上abc试试，也就是访问localhost：8080/abc/index.html这个路径，按理说就能正常访问。要这样访问页面我们要配置一下devserver的publicpath：“/abc/”，配置完后重启访问localhost：8080/abc/index.html，发现可以正常访问了。

- 其实到现在我们应该能了解这个“/”路径代表的是绝对路径，我们在本地访问的时候，这个根路径就是localhost：8080。如果部署到服务器上，这个根路径将会是服务器的根目录。比如将来项目地址是http://jyy.test.com/abc:8080,我们配置的output里面的publicpath：“/”，那资源路径地址将是“http://jyy.test.com/app.js”,如果找不到这个资源文件，那页面将出现白屏。此时如果我们配置publicpath：“./”,这个相对路径也就是说和html平级，将来资源路径会是http://jyy.test.com/abc：8080/app.js,在app.js和html平级的前提下这样就能正常访问了。也就是说如果项目里你不知道publicpath怎么配置的话，配置相对路径是没问题的。
- 我们看个例子，将output里面的publicpath：“./”,而devserver里的publicpath：“/abc/”，重启页面访问localhost：8080/abc/index.html看看效果，发现页面可以正常访问，资源也都正常获取到了

![diff](/assets/img/sample/webpack-22.png)

> 同样的，我们build一下看看打包后的结果。

![diff](/assets/img/sample/webpack-23.png)

> 根据dist目录文件层级关系，也能看出来设置output里面的publicpath：“./”，就能正常访问到静态资源。不管你将来是把dist目录下的文件放到服务器的哪个文件夹下，用相对地址都能访问。如果你确定将来dist目录会存放到服务器的abc文件夹下，那我们也可以把publicpath：“/abc”，这样也不会出错。












