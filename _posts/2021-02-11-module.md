---
title: 模块化
author: jyy
date: 2021-02-11 10:10:00 +0800
# categories: [Blogging, Tutorial]
tags: [js]
pin: true
---

**1.模块化发展历程**   
> 命名空间模式 -》 自执行函数 -》commonjs -》amd -》umd -》cmd -》esm

**2.为什么需要模块化**  
1.团队多人协作，需要引用别人的代码
2.项目交接，我们在阅读和重构别人的代码
3.不同的环境，环境变量不同

基于以上场景，当前js模块化主要有以下几个目的：
1.防止污染全局作用域
2.代码复用性和可维护性
3.功能代码松耦合
4.解决依赖关系不明显的问题

**3.命名空间模式**

> 这种方式"污染"了全局变量，这样的写法会暴露所有模块内的成员，内部状态可以被外部改写

```js
var mathUtils1 = {
    add: function(x, y) {
        return x + y;
    }
}

var mathUtils2 = {
    add: function(x, y, z) {
        return x + y + z;
    }
}

mathUtils.add();
mathUtils.square();

```
**4.自执行函数模式**
> 可以达到不暴露私有成员的目的,但是依赖关系不明显。

**5.commonjs模式**
> 优点：解决了依赖、全局变量污染的问题.
> 缺点：1.CommonJS用同步的方式加载模块，在服务端，模块文件都存在本地磁盘，读取非常快，所以这样做不会有问题。但是在浏览器端，js线程会阻碍ui线程，造成页面卡顿，CommonJS不适合浏览器端模块加载，更合理的方案是使用异步加载。
2.CommonJS模块加载的是输出值的拷贝，一旦输出一个值，模块内部的变化就影响不到这个值。
3.模块加载一次后值会被缓存起来。
4.运行时加载。

**6.amd模式（requirejs）**

> 异步并行加载模块；所有模块加载完成后再执行回调函数.依赖前置（不管是否用到这些模块，都必须提前声明好，也就是提前加载完成。

```js
require(["./modules/a", "./modules/b"], function (a, b) {
    console.log(a, b)
})
define(function () {
    function add(a, b) {
        return a + b
    }
    return { add }
});
```

**7.umd模式**
> 是 AMD 和 CommonJS 的兼容性处理

```js
(function (root, factory) {
    if (typeof exports === 'object') {
        // commonJS
        module.exports = factory();
    } else if (typeof define === 'function' && define.amd) {
        // AMD
        define(factory);
    } else {
        // 挂载到全局
        root.eventUtil = factory();
    }
})(this, function () {
    function myFunc(){};

    return {
        foo: myFunc
    };
});

```
**8.cmd模式(seajs)**
> 回调函数中遇到require才会加载所需模块，依赖就近。

**9.esm模式**
> 输出的是值的引用，并不会缓存值,是编译时输出接口（在import时可以指定加载某个输出值，而不是加载整个模块）