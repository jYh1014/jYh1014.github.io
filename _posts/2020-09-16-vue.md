---
title: vue
author: jyy
date: 2020-09-16 11:00:00 +0800
# categories: [Blogging, Tutorial]
tags: [vue]
pin: true
---

## vue是一个什么样的框架
> 它借鉴了MVVM框架，但是和他并不完全一样。相同之处都是数据变化视图会更新，视图变化数据会被影响（响应式数据原理）。不同之处是MVVM不能跳过数据去直接更新视图，而vue可以通过操作dom来更新视图

> MVVM模型的组成部分
- model（模型）：模型是指代表真实状态内容的领域模型（面向对象），或指代表内容的数据访问层（以数据为中心）。
- view（视图）：视图是用户在屏幕上看到的结构、布局和外观（UI）
- viewModel（视图模型）：
- binder（绑定器）

> 也就是给我什么样的数据，我就渲染出什么样的页面。如下面的html为例，在我修改data数据时，都能渲染出相应的页面。

```html
<body>
    <div id="app" style="color: red">
        {% raw %}
        {{arr}}
        {% endraw %}
        <li> {% raw %}{{school.name}}{% endraw %}</li>
        <li>{% raw %}{{school.age}}{% endraw %}</li>
    </div>
    <script src="./dist/umd/vue.js"></script>
    <script>
        let data = {
            name: "jyy",
            arr: [{ a: 10 }, 2, 3],
            school: { name: "jyy", age: 20 }
        }
        let vm = new Vue({
            el: "#app",
            // data: [1,2,3]
            data: data,
            created() {
                console.log("my created-----")
            }
        })
      
        vm._data.name = "aaaa"
        console.log(vm._data)
      
    </script>
</body>
```
> 想要实现这个效果，必须先知道vue整个的渲染流程：先初始化数据 =》将模版进行编译 =》 生成render函数 =》 生成虚拟节点 =》生成真实的dom =》放到页面上

## 1.初始化数据（对数据的劫持）
> 当我们访问或设置数据的属性的时候，都会触发相对应的函数。也就是说修改数据时，要知道数据是不是做了修改，然后再更新视图。这个就是劫持操作。

> 主要是依赖Object.defineProperty来实现的。

> 下面看一个完整的vue初始化代码

```js
function Vue(options){
    this._init(options)
}
initMixin(Vue) //用插件的方式来扩展方法。

function initMixin(Vue){
    Vue.prototype._init = function(options){
        let vm = this
        vm.$options = options
        initState(vm)
    }
}
function initState(vm){
    let options = vm.$options
    if(options.data){
        initData(vm)
    }
}

function initData(vm){
    let data = vm.$options.data
    vm._data = data = typeof data === "function"?data.call(vm):data
    observe(data)
}

function observe(data){
    if(typeof data != "object"){
        return; //只对对象和数组做监测
    }
    if (Array.isArray(data)) {
        observeArray(data) //观测数组中的对象类型
    } else {
        walk(data)
    }
}

function walk(data){
    let keys = Object.keys(data)
    keys.forEach(key => {
        defineReactive(data, key, data[key])
    })
}
 function observeArray(data) {
    data.forEach(item => {
        observe(item)
    })
}
function defineReactive(data, key, value) {
    observe(value) //递归
    Object.defineProperty(data, key, {
        get() {
            console.log(`读取了${key}属性`)
            return value
        },
        set(newValue) {
            console.log(`设置了${key}属性`)
            if (newValue == value) return
            value = newValue
        }
    })
}
//此时在html中加上vm._data.name = "aaa"就会触发set函数执行，也就是说得到了劫持。
//但是 vm._data.name={a:10}并不会触发set，我们需要修改一下defineReactive方法的代码。
function defineReactive(data, key, value) {
    observe(value)
    Object.defineProperty(data, key, {
        get() {
            console.log(`读取了${key}属性`)
            return value
        },
        set(newValue) {
            console.log(`设置了${key}属性`)
            if (newValue == value) return
            observe(newValue) //需要对重新赋值的数据也做监测
            value = newValue
        }
    })
}
//到此为止，对对象类型的劫持已经完成，但是对数组类型的劫持还有欠缺，在vue中，只对数组的这些方法做了监测，push、pop、shift
//、unshift、reverse、sort、splice，这些方法都能修改原始数组。所以，在数组调用这些方法的时候，我们也要做到劫持。我们需要对数组的原始方法做一些扩展。
let oldArrayMethods = Array.prototype
let arrayMethods = Object.create(oldArrayMethods); //继承 arrayMethods.__proto__ == oldArrayMethods
let methods = [
    "push",
    "pop",
    "shift",
    "unshift",
    "sort",
    "reverse",
    "splice"
]
methods.forEach(method => {
    arrayMethods[method] = function(...args){
        console.log("数组方法拦截")
        let result = oldArrayMethods[method].apply(this, args)
        switch (method) {
            case "push": //追加
            case "unshift":
                inserted = args;
                break;
            case "splice":
                inserted = args.slice(2);
                break;
            default:
                break;
        }
        //对数组新增的值也要进行监测，需要调用observeArray方法
        observeArray(inserted)
        return result
    }
})

//vue2对数组监测的弊端在官网上也有说明，以下两种目前还不能做到劫持
//1.当你利用索引直接设置一个数组项时
//2.当你修改数组的长度时
```

## 2.将模版编译成render函数
- 第一步：生成ast树
- 第二步：优化（静态节点可以跳过）
- 第三步：将优化后的AST树转换为可执行的代码

```html
//比如这段html
<div id="app" style={color: "red"}>hello{{name}}<span>hello</span</div>
//我们需要将其编译成

```
```js
_c('div',{id:'app',style:{color:'red'}},_v('hello'+_s(name)),_c('span',null,_v('hello')))。
最终得到的render函数大概就是以下这种形式
function anonymous() {
    with(this){return _c('div',{id:'app',style:{color:'red'}},_v('hello'+_s(name)),_c('span',null,_v('hello')))}
}
```
> 其中涉及两个过程，1:需要将html代码转换成ast语法树 2:通过这棵树重新生成虚拟节点

```js
//将_init方法修改一下
 Vue.prototype._init = function (options) {
    let vm = this
    vm.$options=options
    initState(vm)
    if (vm.$options.el) {
        vm.$mount(vm.$options.el)
    }
}
 Vue.prototype.$mount = function (el) {
    const vm = this
    const options = vm.$options
    el = document.querySelector(el)
    vm.$el = el
    if (!options.render) {
        let template = options.template
        if (!template && el) {
            template = el.outerHTML
        }
        //将模版编译成render函数
        const render = compilerToFunctions(template)
        options.render = render
    }
    //然后挂载这个组件
    //todo。。。
}

function compilerToFunctions(){
    let ast = parseHTML(template) //将html代码转换成ast语法树
    let code = generate(ast) //通过这棵树重新生成虚拟节点
    let render = new Function(`with(this){return ${code}}`)
    return render
}

//以下是根据正则匹配标签的过程。
const ncname = "[a-zA-Z_][\\-\\.0-9a-zA-Z]*"  //标签名
const qnameCapture = `((?:${ncname}\\:)?${ncname})`  //<my:xx>
const startTagOpen = new RegExp(`^<${qnameCapture}`)
const endTag = new RegExp(`^<\\/${qnameCapture}[^>]*>`)
const attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/
const startTagClose = /^\s*(\/?)>/;
const defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g
function parseHTML(html){
        function createASTElement(tagName, attrs){
        return {
            tag: tagName,
            attrs,
            parent: null,
            children: [],
            type: 1
        }
    }
    let root;
    let currentParent;
    let stack = []
    function start(tagName, attrs) {
        let element = createASTElement(tagName,attrs)
        if(!root){
            root = element
        }
        currentParent = element
        stack.push(element)
    }
    function end(tagName) { 
        let element = stack.pop()
        currentParent = stack[stack.length-1]
        if(currentParent){
            element.parent = currentParent
            currentParent.children.push(element)
        }
    }
    function chars(text) {
        text = text.replace(/\s/g,"");
        if(text){
            currentParent.children.push({
                type:3,
                text
            })
        }
     }
    while (html) {
        let textEnd = html.indexOf("<")
        if (textEnd == 0) {
            //肯定是标签
            const startTagMatch = parseStartTag();
            if (startTagMatch) {
                start(startTagMatch.tagName, startTagMatch.attrs)
                continue;
            }
            // console.log(html)
            const endTagMatch = html.match(endTag)
            if (endTagMatch) {
                advance(endTagMatch[0].length)
                end(endTagMatch[1])
                continue;
            }
        }
        let text
        if (textEnd > 0) {
            text = html.substring(0, textEnd)
        }
        if (text) {
            advance(text.length)
            chars(text)
        }
        // break;
        
    }
    function advance(n) {
        html = html.substring(n)
    }
    function parseStartTag() {
        const start = html.match(startTagOpen)
        if (start) {
            const match = {
                tagName: start[1],
                attrs: []
            }
            advance(start[0].length)
            //如果直接是闭合标签，那说明没有属性
            let end;
            let attr;
            while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {

                match.attrs.push({ name: attr[1], value: attr[3] || attr[4] || attr[5] })
                advance(attr[0].length)
                // break;
            }
            if (end) {
                advance(end[0].length)
                return match
            }
            // console.log(html)
        }
    }
    return root
}

//以下是根据ast来生成render函数
//<div id="app" style={color: "red"}>hello{{name}}<span>hello</span</div>
//_c('div',{id:'app',style:{color:'red'}},_v('hello'+_s(name)),_c('span',null,_v('hello')))
const defaultTagRE = /\{\{((?:.|\r?\n)+?)\}\}/g
function genProps(attrs) {
    let str = ''
    for (let i = 0; i < attrs.length; i++) {
        let attr = attrs[i]
        if (attr.name === 'style') {
            let obj = {}
            attr.value.split(";").forEach(item => {
                let [key, value] = item.split(":")
                obj[key] = value
            })
            attr.value = obj
        }
        str += `${attr.name}:${JSON.stringify(attr.value)},`
    }
    return `{${str.slice(0, -1)}}`
}
function gen(node) {
    if (node.type === 1) {
        return generate(node)
    } else {
        let text = node.text
        if (!defaultTagRE.test(text)) {
            return `_v(${JSON.stringify(text)})`
        }
        let tokens = []
        let lastIndex = defaultTagRE.lastIndex = 0
        let match, index
        while (match = defaultTagRE.exec(text)) {
            index = match.index
            if (index > lastIndex) {
                tokens.push(JSON.stringify(text.slice(lastIndex, index)))
            }
            tokens.push(`_s(${match[1].trim()})`)
            lastIndex = index + match[0].length
        }
        if (lastIndex < text.length) {
            tokens.push(JSON.stringify(text.slice(lastIndex)))
        }
        return `_v(${tokens.join("+")})`
    }
}
function genChildren(el) {
    let children = el.children
    if (children) {
        return children.map(child => gen(child)).join(",")
    }
}
function generate(el) {
    let children = genChildren(el)
    let code = `_c('${el.tag}',${el.attrs.length ? `${genProps(el.attrs)}` : 'undefined'}${children ? `,${children}` : ""
        })`
    return code
}
```

## 3.依赖收集
- 利用Obeject.defineProperty()来监听属性变动，将需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上 setter和getter
- 当给这个对象的某个值赋值，就会触发setter，进而监听到数据变化
- 监听到变化之后通知订阅者，需要实现一个消息订阅器Dep，通过维护一个数组subs，用来收集订阅者，数据变动触发notify，再调用订阅者watcher的update方法
> 并不是每次数据修改就会立刻调用watcher的update方法，首先会调用一个queueWatcher方法，将这些watcher先添加到一个队列中，相同的watcher只会保留一个。最终在nextTick方法中执行

```js
function defineReactive(data, key, value) {
    //闭包
    let childDep = observe(value)
    let dep = new Dep() //每个属性都有一个dep
    Object.defineProperty(data, key, {
        get() { //依赖收集
            if(Dep.target){
                dep.depend()
                if(childDep){
                    childDep.dep.depend() //数组或者对象存起来了渲染watcher
                }
            }
            console.log(`读取了${key}属性`)
            return value
        },
        set(newValue) { //依赖更新
            console.log(`设置了${key}属性`)
            if (newValue == value) return
            observe(newValue)
            value = newValue
            dep.notify() //触发更新
        }
    })
}

let id = 0
class Dep {
    constructor() {
        this.subs = []
        this.id = id++
    }
    depend() {
        Dep.target.addDep(this)  //实现双向记忆dep和watcher互相记忆
        // this.subs.push(Dep.target)
        // console.log(this.subs)
    }
    addSub(watcher){
        this.subs.push(watcher)
    }
    notify() {
        console.log(this.subs)
        this.subs.forEach(watcher => watcher.update())
    }
}
Dep.target = null
export function pushTarget(watcher) {
    Dep.target = watcher
}

export function popTarget() {
    Dep.target = null
}

import { popTarget, pushTarget } from "./dep"
import { nextTick } from "../util"
let id = 0
class Watcher {
    constructor(vm, exprOrFn, cb, options) {
        this.vm = vm
        this.user = options.user //用户watcher
        this.isWatcher = typeof options == "boolean" //渲染watcher
        this.exprOrFn = exprOrFn
        this.cb = cb
        this.options = options
        this.id = id++
        this.deps = []
        this.depsId = new Set()
        if (typeof exprOrFn === "function") {
            this.getter = exprOrFn
        } else {
            this.getter = function () {
                let path = exprOrFn.split(".")
                let obj = vm
                for (let i = 0; i < path.length; i++) {
                    obj = obj[path[i]]
                }
                return obj
            }
        }
        this.value = this.get()
    }
    addDep(dep) {
        let id = dep.id
        if (!this.depsId.has(id)) {
            this.deps.push(dep)
            this.depsId.add(id)
            dep.addSub(this)
        }
    }
    get() {
        debugger
        pushTarget(this)
        let result = this.getter()
        popTarget()
        
        return result
    }
    run() {
        debugger
        let newValue = this.get()
        let oldValue = this.value
        this.value = newValue
        if (this.user) {
            this.cb.call(this.vm, newValue, oldValue)
        }
    }
    update() {
        //这里不能每次一更改数据就调用，
        queueWatcher(this)
        // this.get()
        // this.cb.call(this.vm)
    }
}

/**
 *  批处理操作，等所有的同步任务完成后再执行
 * 相同的watcher只保留一个
 */

function flushSchedulerQueue() {
    queue.forEach(watcher => {
        watcher.run()
        // if (watcher.isWatcher) {
        //     watcher.cb()
        // }

    })
    has = {}
    queue = []
    pending = false
}
let queue = []
let has = {}
let pending = false
function queueWatcher(watcher) {
    let id = watcher.id
    if (!has[id]) {
        queue.push(watcher)
        has[id] = true
        if (!pending) {
            nextTick(flushSchedulerQueue)
            pending = true //防抖
        }
    }
}
//nextTick原理涉及到微任务和宏任务
let callbacks = []
let pending = false
let flushCallbacks = function () {
    callbacks.forEach(cb => cb())
    pending = false
    callbacks = []
}
let timerFunc;
if (Promise) {
    timerFunc = function () {
        Promise.resolve().then(flushCallbacks)
    }
} else if (setImmediate) {
    timerFunc = function () {
        setImmediate(flushCallbacks)
    }
} else if (MutationObserver) { //可以监控dom变化，监控完毕后异步更新
    let observe = new MutationObserver(flushCallbacks)
    let textNode = document.createTextNode(1)
    observe.observe(textNode, { characterData: true })
    timerFunc = function () {
        textNode.textContent = 2
    }
} else {
    timerFunc = function () {
        setTimeout(flushCallbacks)
    }
}
export function nextTick(cb) {
    debugger
    callbacks.push(cb)

    if (!pending) {
        timerFunc() //异步
        pending = true
    }
}
```
## 4.virturl dom
> Virtual DOM 其实就是一棵以 JavaScript 对象( VNode 节点)作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。

```js
//一个完整的vnode节点包含的信息
{
    tag: "div", //节点的标签
    el: "div#app", //对真实节点的引用
    text: null, //如果是文本节点，对应文本节点的textContent
    data: null, //属性
    children: [] //自节点
}
```
## 5.dom diff
> 主要是新旧虚拟节点做对比来进行更新。先同级进行比较，再递归比较子节点。
#### 1.先判断是否是相同标签，如果不相同，则直接替换，否则进入具体对比

```js
function patch (oldVnode, vnode) {
   if (oldVnode.tag !== vnode.tag) {
       //1.比较标签，标签不一样，直接替换
        return oldVnode.el.parentNode.replaceChild(createEle(vnode), oldVnode.el)
    }

    //2.标签一样，比较文本<div>111</div>   <div>12</div>
    if (!oldVnode.tag) { //文本比对
        if (oldVnode.text !== vnode.text) {
            return oldVnode.el.textContent = vnode.text
        } else {
            return
        }
    }
    //3.标签一样，需要开始对比属性和儿子。标签一样直接复用老节点，再更新差异即可
    let el = vnode.el = oldVnode.el //复用老节点
     //更新属性
    updateProperties(vnode, oldVnode.data)
    //比较儿子
    let oldChildren = oldVnode.children
    let newChildren = vnode.children
    //老得有儿子，新的没有
    //老得没有儿子，新的有
    //新的老得都有儿子
    if (oldChildren.length > 0 && newChildren.length > 0) {
        updateChildren(oldChildren, newChildren, el)
    } else if (oldChildren.length > 0) {
        el.innerHTML = ""
    } else if (newChildren.length > 0) {
        for (let i = 0; i < newChildren.length; i++) {
            let child = newChildren[i]
            el.appendChild(createEle(child))
        }
    }
}
```

> 新旧节点都有儿子的情况是核心的diff算法，采用双指针diff算法。

```js
//情况1: 新节点只是在尾部比老节点多了一部分或者少了一部分，别的节点都相同
//假设根据一下模版生成vnode1和vnode2,先暂时不考虑key，有没有key对这种情况没影响
<div>
    <li style="background: pink">A</li>
    <li style="background: yellow">B</li>
    <li style="background: blue">C</li>
    <li style="background: green">D</li>
</div>

//vnode2
<div>
    <li style="background: pink">A</li>
    <li style="background: yellow">B</li>
    <li style="background: blue">C</li>
    <li style="background: green">D</li>
    <li style="background: purple">E</li>
</div>

setTimeout(() => {
    patch(vnode1, vnode2)
}, 2000)
```
> 情况1:新节点只是在尾部比老节点多了一部分或者少了一部分节点，别的节点都相同。此时采用头头比较，从头指针A节点开始比较，同时循环新旧节点，哪个先结束，循环就停止，将多余的删除或者添加进去

![diff](/assets/img/sample/1.png)
```js
function isSameVnode(oldVnode, newVnode) {
    return (oldVnode.tag == newVnode.tag) && (oldVnode.key == newVnode.key)
}
function updateChildren(oldChildren, newChildren, parent) {
    let oldStartIndex = 0
    let oldStartVnode = oldChildren[0]
    let oldEndIndex = oldChildren.length - 1
    let oldEndVnode = oldChildren[oldEndIndex]

    let newStartIndex = 0
    let newStartVnode = newChildren[0]
    let newEndIndex = newChildren.length - 1
    let newEndVnode = newChildren[newEndIndex]
    while (newStartIndex <= newEndIndex && oldStartIndex <= oldEndIndex){
        if(isSameVnode(oldStartVnode, newStartVnode)){
            //头头比较
            patch(oldStartVnode, newStartVnode)
            oldStartVnode = oldChildren[++oldStartIndex]
            newStartVnode = newChildren[++newStartIndex]
        }
    }
}
循环结束后，看下图，新的虚拟节点比老的多了一个节点，直接将多出的部分插入到当前新节点的尾节点的下一个之前(向后添加)
```
![diff](/assets/img/sample/2.png)

```js
if (newStartIndex <= newEndIndex) {
    for (let i = newStartIndex; i <= newEndIndex; i++) {
        //可能是向前添加或者向后
        // parent.appendChild(createEle(newChildren[i]))
        //
        let ele = newChildren[newEndIndex + 1] == null ? null : newChildren[newEndIndex + 1].el
        parent.insertBefore(createEle(newChildren[i]), ele)
    }
}
```

> 情况2:新旧节点尾部相同，采用尾尾比较
```js

<div>
    <li style="background: pink">A</li>
    <li style="background: yellow">B</li>
    <li style="background: blue">C</li>
    <li style="background: green">D</li>
</div>

//vnode2
<div>
    <li style="background: purple">E</li>
    <li style="background: pink">A</li>
    <li style="background: yellow">B</li>
    <li style="background: blue">C</li>
    <li style="background: green">D</li>
</div>

setTimeout(() => {
    patch(vnode1, vnode2)
}, 2000)
```

```js
while (newStartIndex <= newEndIndex && oldStartIndex <= oldEndIndex){
    if(isSameVnode(oldStartVnode, newStartVnode)){
        //头头比较
        patch(oldStartVnode, newStartVnode)
        oldStartVnode = oldChildren[++oldStartIndex]
        newStartVnode = newChildren[++newStartIndex]
    }else if(isSameVnode(oldEndVnode, newEndVnode)){
         //尾尾比较
        patch(oldEndVnode, newEndVnode)
        oldEndVnode = oldChildren[--oldEndIndex]
        newEndVnode = newChildren[--newEndIndex]
    }
}
//循环开始图和图1相同，结束后，看下图
```
![diff](/assets/img/sample/3.png)

> 情况3:头和尾比较,通过移动老节点来实现。

```js

<div>
    <li style="background: pink" key="D">D</li>
    <li style="background: yellow" key="B">B</li>
    <li style="background: blue" key="C">C</li>
    <li style="background: green" key="A">A</li>
</div>

//vnode2
<div>
    <li style="background: pink" key="A">A</li>
    <li style="background: yellow" key="C">C</li>
    <li style="background: blue" key="B">B</li>
    <li style="background: green" key="D">D</li>
</div>

setTimeout(() => {
    patch(vnode1, vnode2)
}, 2000)
```
![diff](/assets/img/sample/4.png)
![diff](/assets/img/sample/5.png)
![diff](/assets/img/sample/6.png)
![diff](/assets/img/sample/7.png)
![diff](/assets/img/sample/8.png)

```js
while (newStartIndex <= newEndIndex && oldStartIndex <= oldEndIndex){
    if(isSameVnode(oldStartVnode, newStartVnode)){
        //头头比较
        //...
    }else if(isSameVnode(oldEndVnode, newEndVnode)){
         //尾尾比较
        //...
    }else if(isSameVnode(oldStartVnode, newEndVnode)){
        //头尾比较
        patch(oldStartVnode, newEndVnode)
        parent.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling)
        oldStartVnode = oldChildren[++oldStartIndex]
        newEndVnode = newChildren[--newEndIndex]
    }
}
```

> 情况4:尾和头比较

```js
<div>
    <li style="background: pink" key="B">B</li>
    <li style="background: yellow" key="D">D</li>
    <li style="background: blue" key="C">C</li>
    <li style="background: green" key="A">A</li>
</div>

//vnode2
<div>
    <li style="background: pink" key="A">A</li>
    <li style="background: yellow" key="C">C</li>
    <li style="background: blue" key="B">B</li>
    <li style="background: green" key="D">D</li>
</div>

setTimeout(() => {
    patch(vnode1, vnode2)
}, 2000)
```
![diff](/assets/img/sample/9.png)
![diff](/assets/img/sample/10.png)
![diff](/assets/img/sample/11.png)
![diff](/assets/img/sample/12.png)
![diff](/assets/img/sample/13.png)

```js
while (newStartIndex <= newEndIndex && oldStartIndex <= oldEndIndex){
    if(isSameVnode(oldStartVnode, newStartVnode)){
        //头头比较
       //...
    }else if(isSameVnode(oldEndVnode, newEndVnode)){
         //尾尾比较
       //...
    }else if(isSameVnode(oldStartVnode, newEndVnode)){
        //头尾比较
        //...
    }else if(isSameVnode(oldEndVnode, newStartVnode)){
         //尾 头比较
        patch(oldEndVnode, newStartVnode)
        parent.insertBefore(oldEndVnode.el, newStartVnode.el)
        oldEndVnode = oldChildren[--oldEndIndex]
        newStartVnode = newChildren[++newStartIndex]
    }
}
```

> 情况5:就是儿子之间不能找到明显的关系，这个时候要用新节点不停的去老节点里面找，找到就移动以复用节点

```js
<div>
    <li style="background: pink" key="C">C</li>
    <li style="background: yellow" key="D">D</li>
    <li style="background: blue" key="E">E</li>
    <li style="background: green" key="M">M</li>
</div>

//vnode2
<div>
    <li style="background: pink" key="A">A</li>
    <li style="background: yellow" key="C">C</li>
    <li style="background: blue" key="E">E</li>
    <li style="background: green" key="Q">Q</li>
</div>

setTimeout(() => {
    patch(vnode1, vnode2)
}, 2000)
```
![diff](/assets/img/sample/14.png)
![diff](/assets/img/sample/15.png)
![diff](/assets/img/sample/16.png)
![diff](/assets/img/sample/17.png)
![diff](/assets/img/sample/18.png)
![diff](/assets/img/sample/19.png)

```js
while (newStartIndex <= newEndIndex && oldStartIndex <= oldEndIndex){
    if(isSameVnode(oldStartVnode, newStartVnode)){
       //...
    }else if(isSameVnode(oldEndVnode, newEndVnode)){
         //尾尾比较
        //...
    }else if(isSameVnode(oldStartVnode, newEndVnode)){
        //头尾比较
        //...
    }else if(isSameVnode(oldEndVnode, newStartVnode)){
         //尾 头比较
        //...
    }else{
        let moveIndex = oldChildren[newStartVnode.key]
        if (moveIndex == undefined) { //不需要移动，没有可复用的
            parent.insertBefore(createEle(newStartVnode), oldStartVnode.el)
        } else {
            let moveVnode = oldChildren[moveIndex] //这个老得节点需要移动
            oldChildren[moveIndex] = null
            parent.insertBefore(moveVnode.el, oldStartVnode.el)
            patch(moveVnode, newStartVnode)
        }
        newStartVnode = newChildren[++newStartIndex]
    }
}
if (oldStartIndex <= oldEndIndex) {
    //删除多余的老节点
    for (let i = oldStartIndex; i <= oldEndIndex; i++) {
        let child = oldChildren[i]
        if (child != undefined) {
            patch.removeChild(child.el)
        }
    }
}
```

#### 为什么要用key？
>分析情况3，如果不使用key，在比较第一个li的时候，就会直接复用老节点的第一个li，然后再进一步把D更新为A。如果加上key属性，则只需要复用老节点，通过移动老节点来达到目的，他能通过key来精准的找到可以复用的节点。这样性能会高一些。

#### 不能用index作为key

```js
<template>
    <div v-for="(item, index) in list" :key="index" >{{item.name}}</div>
</template>

const list = [
    {
        id: 1,
        name: "Person1"
    },
    {
        id: 2,
        name: "Person2"
    },
    {
        id: 3,
        name: "Person3"
    },
    {
        id:4,
        name:"Person4"
    }
];
```
- 原因1和使用key的原因相同。
- 原因2:删除列表其中一个元素Person2后，会造成Person3和Person4重新渲染（因为key变了）。
- 原因3:如果此时 list 的 item 是 select 的选项，其中 Person3 是选中的，这个时候 Person2 被删除了，用 index 作为 key 就会变成是 Person4 选中的了，这就产生了bug。