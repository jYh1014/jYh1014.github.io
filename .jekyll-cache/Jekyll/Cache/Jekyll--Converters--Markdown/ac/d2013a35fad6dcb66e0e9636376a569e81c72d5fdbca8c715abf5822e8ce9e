I"?O<h2 id="iterator遍历器">iterator遍历器</h2>

<blockquote>
  <p>es6上是这样定义的：它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作</p>
</blockquote>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre></td><td class="rouge-code"><pre>模拟一个遍历器生存函数
<span class="k">function </span>makeIterator<span class="o">(</span>arr<span class="o">){</span>
    <span class="nb">let </span>index <span class="o">=</span> 0
    <span class="k">return</span> <span class="o">{</span>
        next: <span class="k">function</span><span class="o">(){</span>
            <span class="k">if</span><span class="o">(</span>index &lt; arr.length<span class="o">){</span>
                <span class="k">return</span> <span class="o">{</span>
                    value: arr[index++],
                    <span class="k">done</span>: <span class="nb">false</span>
                <span class="o">}</span>
            <span class="o">}</span><span class="k">else</span><span class="o">{</span>
                <span class="k">return</span> <span class="o">{</span>
                    value: undefined,
                    <span class="k">done</span>: <span class="nb">true</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="nb">let </span>it <span class="o">=</span> makeIterator<span class="o">([</span><span class="s2">"a"</span>,<span class="s2">"b"</span><span class="o">])</span>
console.log<span class="o">(</span>it.next<span class="o">())</span>
console.log<span class="o">(</span>it.next<span class="o">())</span>
console.log<span class="o">(</span>it.next<span class="o">())</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>ES6 规定，默认的 Iterator 接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”.<br />
原生具备 Iterator 接口的数据结构如下:</p>
<ul>
  <li>Array</li>
  <li>Map</li>
  <li>Set</li>
  <li>String</li>
  <li>TypedArray</li>
  <li>函数的 arguments 对象</li>
  <li>NodeList 对象</li>
</ul>

<p>下面是为一个对象添加iterator接口的例子</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="nb">let </span>obj <span class="o">=</span> <span class="o">{</span>
  data: <span class="o">[</span> <span class="s1">'hello'</span>, <span class="s1">'world'</span> <span class="o">]</span>,
  <span class="o">[</span>Symbol.iterator]<span class="o">()</span> <span class="o">{</span>
    const self <span class="o">=</span> this<span class="p">;</span>
    <span class="nb">let </span>index <span class="o">=</span> 0<span class="p">;</span>
    <span class="k">return</span> <span class="o">{</span>
      next<span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span>index &lt; self.data.length<span class="o">)</span> <span class="o">{</span>
          <span class="k">return</span> <span class="o">{</span>
            value: self.data[index++],
            <span class="k">done</span>: <span class="nb">false</span>
          <span class="o">}</span><span class="p">;</span>
        <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
          <span class="k">return</span> <span class="o">{</span> value: undefined, <span class="k">done</span>: <span class="nb">true</span> <span class="o">}</span><span class="p">;</span>
        <span class="o">}</span>
      <span class="o">}</span>
    <span class="o">}</span><span class="p">;</span>
  <span class="o">}</span>
<span class="o">}</span><span class="p">;</span>
<span class="k">for</span><span class="o">(</span><span class="nb">let </span>item of obj<span class="o">){</span>
    console.log<span class="o">(</span>item<span class="o">)</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="generator函数">generator函数</h2>

<blockquote>
  <p>在了解了回调函数和promise解决异步编程的不足之后，generator函数可以解决这些问题。
还有一种处理异步编程的方案叫做协程：意思是多个线程互相协作，完成异步任务。</p>
</blockquote>

<p>它的运行流程大致如下：</p>
<ul>
  <li>第一步，协程A开始执行</li>
  <li>第二步，协程A执行到一半，进入暂停，执行权转移到协程B</li>
  <li>第三步，（一段时间后）协程B交还执行权</li>
  <li>第四步，协程A恢复执行</li>
</ul>

<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。
Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）,yield命令是异步两个阶段的分界线。</p>

<p>下面看一个用Generator 函数来执行异步任务的例子：</p>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre></td><td class="rouge-code"><pre><span class="nb">let </span>fetch <span class="o">=</span> require<span class="o">(</span><span class="s1">'node-fetch'</span><span class="o">)</span><span class="p">;</span>

<span class="k">function*</span> gen<span class="o">(){</span>
  <span class="nb">let </span>url <span class="o">=</span> <span class="s1">'https://api.github.com/users/github'</span><span class="p">;</span>
  <span class="nb">let </span>result <span class="o">=</span> yield fetch<span class="o">(</span>url<span class="o">)</span><span class="p">;</span>
  console.log<span class="o">(</span>result.bio<span class="o">)</span><span class="p">;</span>
<span class="o">}</span>
<span class="nb">let </span>g <span class="o">=</span> gen<span class="o">()</span><span class="p">;</span>
<span class="nb">let </span>result <span class="o">=</span> g.next<span class="o">()</span><span class="p">;</span>

result.value.then<span class="o">(</span><span class="k">function</span><span class="o">(</span>data<span class="o">){</span>
  <span class="k">return </span>data.json<span class="o">()</span><span class="p">;</span>
<span class="o">})</span>.then<span class="o">(</span><span class="k">function</span><span class="o">(</span>data<span class="o">){</span>
  g.next<span class="o">(</span>data<span class="o">)</span><span class="p">;</span>
<span class="o">})</span><span class="p">;</span>
可以看出虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便。
</pre></td></tr></tbody></table></code></pre></div></div>
<p>es6文档上指出thunk函数可以用于 Generator 函数的自动流程管理。</p>

<h2 id="thunk函数">Thunk函数</h2>

<blockquote>
  <p>编译器的“传名调用”实现，是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做 Thunk 函数</p>
</blockquote>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="k">function </span>f<span class="o">(</span>m<span class="o">)</span> <span class="o">{</span>
  <span class="k">return </span>m <span class="k">*</span> 2<span class="p">;</span>
<span class="o">}</span>
f<span class="o">(</span>x + 5<span class="o">)</span><span class="p">;</span>

// 等同于

<span class="nb">let </span>thunk <span class="o">=</span> <span class="k">function</span> <span class="o">()</span> <span class="o">{</span>
  <span class="k">return </span>x + 5<span class="p">;</span>
<span class="o">}</span><span class="p">;</span>
<span class="k">function </span>f<span class="o">(</span>thunk<span class="o">)</span> <span class="o">{</span>
  <span class="k">return </span>thunk<span class="o">()</span> <span class="k">*</span> 2<span class="p">;</span>
<span class="o">}</span>

</pre></td></tr></tbody></table></code></pre></div></div>
<blockquote>
  <p>JavaScript 语言是传值调用,Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。
任何函数，只要参数有回调函数，就能写成 Thunk 函数的形式</p>
</blockquote>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>// 正常版本的readFile（多参数版本）
fs.readFile<span class="o">(</span>fileName, callback<span class="o">)</span><span class="p">;</span>

// Thunk版本的readFile（单参数版本）
<span class="nb">let </span>Thunk <span class="o">=</span> <span class="k">function</span> <span class="o">(</span>fileName<span class="o">)</span> <span class="o">{</span>
  <span class="k">return function</span> <span class="o">(</span>callback<span class="o">)</span> <span class="o">{</span>
    <span class="k">return </span>fs.readFile<span class="o">(</span>fileName, callback<span class="o">)</span><span class="p">;</span>
  <span class="o">}</span><span class="p">;</span>
<span class="o">}</span><span class="p">;</span>

<span class="nb">let </span>readFileThunk <span class="o">=</span> Thunk<span class="o">(</span>fileName<span class="o">)</span><span class="p">;</span>
readFileThunk<span class="o">(</span>callback<span class="o">)</span><span class="p">;</span>

</pre></td></tr></tbody></table></code></pre></div></div>
<h2 id="thunkify-模块">Thunkify 模块</h2>
<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre>//使用方式：以读取文件为例
<span class="nb">let </span>thunkify <span class="o">=</span> require<span class="o">(</span><span class="s1">'thunkify'</span><span class="o">)</span><span class="p">;</span>
<span class="nb">let </span>fs <span class="o">=</span> require<span class="o">(</span><span class="s1">'fs'</span><span class="o">)</span><span class="p">;</span>
<span class="nb">let read</span> <span class="o">=</span> thunkify<span class="o">(</span>fs.readFile<span class="o">)</span><span class="p">;</span>
<span class="nb">read</span><span class="o">(</span><span class="s1">'package.json'</span><span class="o">)(</span><span class="k">function</span><span class="o">(</span>err, str<span class="o">){</span>
  // ...
<span class="o">})</span><span class="p">;</span>
//源码实现：
<span class="k">function </span>thunkify<span class="o">(</span>fn<span class="o">)</span> <span class="o">{</span>
  <span class="k">return function</span><span class="o">()</span> <span class="o">{</span>
    <span class="nb">let </span>args <span class="o">=</span> new Array<span class="o">(</span>arguments.length<span class="o">)</span><span class="p">;</span>
    <span class="nb">let </span>ctx <span class="o">=</span> this<span class="p">;</span>

    <span class="k">for</span> <span class="o">(</span><span class="nb">let </span>i <span class="o">=</span> 0<span class="p">;</span> i &lt; args.length<span class="p">;</span> ++i<span class="o">)</span> <span class="o">{</span>
      args[i] <span class="o">=</span> arguments[i]<span class="p">;</span>
    <span class="o">}</span>

    <span class="k">return function</span> <span class="o">(</span><span class="k">done</span><span class="o">)</span> <span class="o">{</span>
      <span class="nb">let </span>called<span class="p">;</span>
      args.push<span class="o">(</span><span class="k">function</span> <span class="o">()</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span>called<span class="o">)</span> <span class="k">return</span><span class="p">;</span>
        called <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">done</span>.apply<span class="o">(</span>null, arguments<span class="o">)</span><span class="p">;</span>
      <span class="o">})</span><span class="p">;</span>

      try <span class="o">{</span>
        fn.apply<span class="o">(</span>ctx, args<span class="o">)</span><span class="p">;</span>
      <span class="o">}</span> catch <span class="o">(</span>err<span class="o">)</span> <span class="o">{</span>
        <span class="k">done</span><span class="o">(</span>err<span class="o">)</span><span class="p">;</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>
<h2 id="generator-函数的流程管理">Generator 函数的流程管理</h2>
<blockquote>
  <p>Thunk 函数现在可以用于 Generator 函数的自动流程管理</p>
</blockquote>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="nb">let </span>fs <span class="o">=</span> require<span class="o">(</span><span class="s1">'fs'</span><span class="o">)</span><span class="p">;</span>
<span class="nb">let </span>thunkify <span class="o">=</span> require<span class="o">(</span><span class="s1">'thunkify'</span><span class="o">)</span><span class="p">;</span>
<span class="nb">let </span>readFileThunk <span class="o">=</span> thunkify<span class="o">(</span>fs.readFile<span class="o">)</span><span class="p">;</span>

<span class="nb">let </span>gen <span class="o">=</span> <span class="k">function*</span> <span class="o">(){</span>
  <span class="nb">let </span>r1 <span class="o">=</span> yield readFileThunk<span class="o">(</span><span class="s1">'/etc/fstab'</span><span class="o">)</span><span class="p">;</span>
  console.log<span class="o">(</span>r1.toString<span class="o">())</span><span class="p">;</span>
  <span class="nb">let </span>r2 <span class="o">=</span> yield readFileThunk<span class="o">(</span><span class="s1">'/etc/shells'</span><span class="o">)</span><span class="p">;</span>
  console.log<span class="o">(</span>r2.toString<span class="o">())</span><span class="p">;</span>
<span class="o">}</span><span class="p">;</span>
//先看如何手动执行上面这个 Generator 函数
<span class="nb">let </span>g <span class="o">=</span> gen<span class="o">()</span><span class="p">;</span>
<span class="nb">let </span>r1 <span class="o">=</span> g.next<span class="o">()</span><span class="p">;</span>
r1.value<span class="o">(</span><span class="k">function</span> <span class="o">(</span>err, data<span class="o">)</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span>err<span class="o">)</span> throw err<span class="p">;</span>
  <span class="nb">let </span>r2 <span class="o">=</span> g.next<span class="o">(</span>data<span class="o">)</span><span class="p">;</span>
  r2.value<span class="o">(</span><span class="k">function</span> <span class="o">(</span>err, data<span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span>err<span class="o">)</span> throw err<span class="p">;</span>
    g.next<span class="o">(</span>data<span class="o">)</span><span class="p">;</span>
  <span class="o">})</span><span class="p">;</span>
<span class="o">})</span><span class="p">;</span>
//可以发现 Generator 函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程
</pre></td></tr></tbody></table></code></pre></div></div>

<h2 id="thunk-函数的自动流程管理">Thunk 函数的自动流程管理</h2>
<h2 id="co模块">co模块</h2>

<blockquote>
  <p>用于 Generator 函数的自动执行，co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象</p>
</blockquote>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td><td class="rouge-code"><pre>const fs <span class="o">=</span> require<span class="o">(</span><span class="s2">"fs"</span><span class="o">)</span>.promises

<span class="k">function*</span> <span class="nb">read</span><span class="o">()</span> <span class="o">{</span>
    <span class="nb">let </span>name <span class="o">=</span> yield fs.readFile<span class="o">(</span><span class="s2">"name.txt"</span>, <span class="s2">"utf8"</span><span class="o">)</span>
    <span class="nb">let </span>age <span class="o">=</span> yield fs.readFile<span class="o">(</span>name, <span class="s2">"utf8"</span><span class="o">)</span>
    <span class="nb">let </span>xx <span class="o">=</span> yield <span class="o">{</span> a: age + 20 <span class="o">}</span>
    <span class="k">return </span>xx
<span class="o">}</span>
co<span class="o">(</span><span class="nb">read</span><span class="o">)</span>.then<span class="o">(</span>data <span class="o">=&gt;</span> <span class="o">{</span>
    console.log<span class="o">(</span>data<span class="o">)</span>
<span class="o">})</span>
//源码实现如下：
<span class="k">function </span>co<span class="o">(</span>gen<span class="o">)</span> <span class="o">{</span>
    <span class="nb">let </span>self <span class="o">=</span> this
    <span class="k">return </span>new Promise<span class="o">((</span>resolve, reject<span class="o">)</span> <span class="o">=&gt;</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span>typeof gen <span class="o">===</span> <span class="s2">"function"</span><span class="o">)</span> <span class="o">{</span>
            gen <span class="o">=</span> gen.call<span class="o">(</span>self<span class="o">)</span>
        <span class="o">}</span>
        <span class="k">function </span>next<span class="o">(</span>data<span class="o">)</span> <span class="o">{</span>
            <span class="nb">let</span> <span class="o">{</span> value, <span class="k">done</span> <span class="o">}</span> <span class="o">=</span> gen.next<span class="o">(</span>data<span class="o">)</span>
            <span class="k">if</span> <span class="o">(</span><span class="k">done</span><span class="o">)</span> <span class="o">{</span>
                resolve<span class="o">(</span>value<span class="o">)</span>
            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
                Promise.resolve<span class="o">(</span>value<span class="o">)</span>.then<span class="o">(</span>data <span class="o">=&gt;</span> <span class="o">{</span>
                    console.log<span class="o">(</span>data<span class="o">)</span>
                    next<span class="o">(</span>data<span class="o">)</span>
                <span class="o">}</span>, err <span class="o">=&gt;</span> console.log<span class="o">(</span>err<span class="o">))</span>
            <span class="o">}</span>

        <span class="o">}</span>
        next<span class="o">()</span>
    <span class="o">})</span>
<span class="o">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>
:ET