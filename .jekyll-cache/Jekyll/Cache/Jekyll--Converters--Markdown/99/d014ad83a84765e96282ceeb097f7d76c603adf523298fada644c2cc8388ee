I"K<h2 id="promise介绍">promise介绍</h2>
<blockquote>
  <p><strong>1.promise是什么?</strong> <br />
promise对象是一个构造函数。</p>
</blockquote>

<blockquote>
  <p><strong>2.promise的应用场景</strong> <br />
Promise 是异步编程的一种解决方案。主要是为了解决回调地狱的问题。下面来看个回调嵌套的小例子：</p>
</blockquote>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td> --><td class="rouge-code"><pre>fs.readFile("name.txt", "utf8", function(err,data){
    if(data){
        fs.readFile(data, "utf8", function(err1,data1){
            // console.log(err1,data1)
        })
    }
})
改造成promise后，用链式调用的方式。
function readFile(...args) {
    return new Promise((resolve, reject) =&gt; {
        fs.readFile(...args, (err, data) =&gt; {
            if(err) reject(err)
            resolve(data)
        })
    })
}
readFile("name.txt", "utf8").then(data =&gt; {
    return readFile(data, "utf8");
}, err =&gt; {
    console.log("err1"+err)
})
</pre></td></tr></tbody></table></code></pre></div></div>

<blockquote>
  <p><strong>3.promise原理</strong></p>
</blockquote>

<p>首先实现一个最简单的：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td> --><td class="rouge-code"><pre>let promise = new Promise((resolve, reject) =&gt; {
    resolve("ok")
})
promise.then(data =&gt; {
    console.log(“success: " + data)
}, err =&gt; {
    console.log("error: " + err)
})
源码实现如下：
class Promise {
    constructor(executor){
        this.value = undefined
        this.reason = undefined
        let resolve = (value) =&gt; {
            this.value = value
        }
        let reject = (reason) =&gt; {
            this.reason = reason
        }
        executor(resolve, reject)
    }
    then(onfulfilled, onreject){
        onfulfilled(this.value)
    }
}
module.exports = Promise
</pre></td></tr></tbody></table></code></pre></div></div>
<p>resolve是异步操作成功后执行的，如果异步操作失败则要执行reject,此时就要考虑加状态，成功”FULFILLED”、失败”REJECTED”、进行中”PENDDING”</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre></td> --><td class="rouge-code"><pre>let promise = new Promise((resolve, reject) =&gt; {
    reject("出错了")
})
源码实现：
const PENDDING = "PENDDING"
const FULFILLED = "FULFILLED"
const REJECTED = "REJECTED"
class Promise{
    constructor(executor){
        this.value = undefined
        this.reason = undefined
        this.status = undefined
        let resolve = (value) =&gt; {
            this.value = value
            this.status = FULFILLED 
        }
        let reject = (reason) =&gt; {
            this.reason = reason
            this.status = REJECTED
        }
        executor(resolve, reject)
    }
    then(onfulfilled, onreject){
        if(this.status === FULFILLED){
            onfulfilled(this.value)
        }
        if(this.status === REJECTED){
            onreject(this.reason)
        }
        
    }
}
module.exports = Promise
</pre></td></tr></tbody></table></code></pre></div></div>
<p>到此一个简单的promise源码已经差不多了，但是实际应用中往往很复杂，最常见的就是和定时器的组合。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre></td> --><td class="rouge-code"><pre>let promise = new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
        resolve("ok")
    },1000)
})
promise.then(data =&gt; {
    console.log(“success: " + data)
}, err =&gt; {
    console.log("error: " + err)
})
这种情况需要利用resolveCallbacks和rejectCallbacks来做一个缓存。

class Promise{
    constructor(executor){
        this.value = undefined
        this.reason = undefined
        this.status = PENDDING
        this.resolveCallbacks = []
        this.rejectCallbacks = []
        let resolve = (value) =&gt; {
            this.value = value
            this.status = FULFILLED 
            this.resolveCallbacks.forEach(fn =&gt; fn())
        }
        let reject = (reason) =&gt; {
            this.reason = reason
            this.status = REJECTED
            this.rejectCallbacks.forEach(fn =&gt; fn())
        }
        executor(resolve, reject)
    }
    then(onfulfilled, onreject){
        if(this.status === FULFILLED){
            onfulfilled(this.value)
        }
        if(this.status === REJECTED){
            onreject(this.reason)
        }
        if(this.status === PENDDING){
            this.resolveCallbacks.push(() =&gt; {
                onfulfilled(this.value)
            })
            this.rejectCallbacks.push(() =&gt; {
                onreject(this.reason)
            })
        }
    }
}
module.exports = Promise
</pre></td></tr></tbody></table></code></pre></div></div>
<p>es6文档上写的promise其中一个特点是一旦状态改变，就不会再变，但是看下面代码：</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><!-- <td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td> --><td class="rouge-code"><pre>let promise = new Promise((resolve, reject) =&gt; {
    resolve("ok")
    reject("出错了")
})
promise.then(data =&gt; {
    console.log(“success: " + data)
}, err =&gt; {
    console.log("error: " + err)
})
promise的最终状态竟然是reject，正确的结果应该是resolve
</pre></td></tr></tbody></table></code></pre></div></div>
:ET