I"	<h2 id="浏览器事件循环机制">浏览器事件循环机制</h2>
<blockquote>
  <p>主线程从”任务队列”中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。</p>
</blockquote>

<h3 id="1javascript是单线程非阻塞的">1.JavaScript是单线程，非阻塞的</h3>
<blockquote>
  <p>JavaScript语言的一大特点就是单线程，也就是说，同一个时间只能做一件事.</p>
</blockquote>

<blockquote>
  <p>单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。</p>
</blockquote>

<h3 id="2任务队列">2.任务队列</h3>
<blockquote>
  <p>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）.</p>
</blockquote>

<blockquote>
  <p>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务；异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程，某个异步任务可以执行了，该任务（其实就是异步任务指定的回调函数）才会进入主线程执行。</p>
</blockquote>

<h3 id="3event-loop执行过程">3.event-loop执行过程</h3>

<p>（1）所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）。</p>

<p>（2）主线程之外，还存在一个”任务队列”（task queue）。只要异步任务有了运行结果，就在”任务队列”之中放置一个事件。</p>

<p>（3）一旦”执行栈”中的所有同步任务执行完毕，系统就会读取”任务队列”，看看里面有哪些事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行。</p>

<p>（4）主线程不断重复上面的第三步。</p>

<h3 id="4微任务和宏任务">4.微任务和宏任务</h3>
<blockquote>
  <p>异步任务又可划分为微任务和宏任务。
宏任务：script(整体代码)、setTimeout、setInterval、postMessage、I/O（node）setImmediate、UI rendering
微任务：Promise.then、MutaionObserver、process.nextTick（Node.js）</p>
</blockquote>
:ET